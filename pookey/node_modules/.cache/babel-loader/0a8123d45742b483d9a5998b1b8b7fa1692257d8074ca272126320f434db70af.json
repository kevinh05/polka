{"ast":null,"code":"import { catchError, combineLatest, map, of, switchMap } from 'rxjs';\nimport { isNumber, isUndefined } from '@polkadot/util';\nimport { unwrapBlockNumber } from '../util/index.js';\nimport { FALLBACK_MAX_HASH_COUNT, FALLBACK_PERIOD, MAX_FINALITY_LAG, MORTAL_PERIOD } from './constants.js';\nfunction latestNonce(api, address) {\n  return api.derive.balances.account(address).pipe(map(({\n    accountNonce\n  }) => accountNonce));\n}\nfunction nextNonce(api, address) {\n  if (api.call.accountNonceApi) {\n    return api.call.accountNonceApi.accountNonce(address);\n  } else {\n    return api.rpc.system?.accountNextIndex ? api.rpc.system.accountNextIndex(address) : latestNonce(api, address);\n  }\n}\nfunction signingHeader(api) {\n  return combineLatest([api.rpc.chain.getHeader().pipe(switchMap(header =>\n  // check for chains at genesis (until block 1 is produced, e.g. 6s), since\n  // we do need to allow transactions at chain start (also dev/seal chains)\n  header.parentHash.isEmpty ? of(header)\n  // in the case of the current block, we use the parent to minimize the\n  // impact of forks on the system, but not completely remove it\n  : api.rpc.chain.getHeader(header.parentHash).pipe(catchError(() => of(header))))), api.rpc.chain.getFinalizedHead().pipe(switchMap(hash => api.rpc.chain.getHeader(hash).pipe(catchError(() => of(null)))))]).pipe(map(([current, finalized]) =>\n  // determine the hash to use, current when lag > max, else finalized\n  !finalized || unwrapBlockNumber(current).sub(unwrapBlockNumber(finalized)).gt(MAX_FINALITY_LAG) ? current : finalized));\n}\nfunction babeOrAuraPeriod(api) {\n  const period = api.consts.babe?.expectedBlockTime ||\n  // this will be present ones https://github.com/paritytech/polkadot-sdk/pull/3732 is merged\n  api.consts['aura']?.slotDuration || api.consts.timestamp?.minimumPeriod.muln(2);\n  return period && period.isZero && !period.isZero() ? period : undefined;\n}\nexport function signingInfo(_instanceId, api) {\n  // no memo, we want to do this fresh on each run\n  return (address, nonce, era) => combineLatest([\n  // retrieve nonce if none was specified\n  isUndefined(nonce) ? latestNonce(api, address) : nonce === -1 ? nextNonce(api, address) : of(api.registry.createType('Index', nonce)),\n  // if no era (create) or era > 0 (mortal), do block retrieval\n  isUndefined(era) || isNumber(era) && era > 0 ? signingHeader(api) : of(null)]).pipe(map(([nonce, header]) => ({\n    header,\n    mortalLength: Math.min(api.consts.system?.blockHashCount?.toNumber() || FALLBACK_MAX_HASH_COUNT, MORTAL_PERIOD.div(babeOrAuraPeriod(api) || FALLBACK_PERIOD).iadd(MAX_FINALITY_LAG).toNumber()),\n    nonce\n  })));\n}","map":{"version":3,"names":["catchError","combineLatest","map","of","switchMap","isNumber","isUndefined","unwrapBlockNumber","FALLBACK_MAX_HASH_COUNT","FALLBACK_PERIOD","MAX_FINALITY_LAG","MORTAL_PERIOD","latestNonce","api","address","derive","balances","account","pipe","accountNonce","nextNonce","call","accountNonceApi","rpc","system","accountNextIndex","signingHeader","chain","getHeader","header","parentHash","isEmpty","getFinalizedHead","hash","current","finalized","sub","gt","babeOrAuraPeriod","period","consts","babe","expectedBlockTime","slotDuration","timestamp","minimumPeriod","muln","isZero","undefined","signingInfo","_instanceId","nonce","era","registry","createType","mortalLength","Math","min","blockHashCount","toNumber","div","iadd"],"sources":["C:/Users/khyy4/Documents/Code-Projects/polkahack/pookey/node_modules/@polkadot/api-derive/tx/signingInfo.js"],"sourcesContent":["import { catchError, combineLatest, map, of, switchMap } from 'rxjs';\nimport { isNumber, isUndefined } from '@polkadot/util';\nimport { unwrapBlockNumber } from '../util/index.js';\nimport { FALLBACK_MAX_HASH_COUNT, FALLBACK_PERIOD, MAX_FINALITY_LAG, MORTAL_PERIOD } from './constants.js';\nfunction latestNonce(api, address) {\n    return api.derive.balances.account(address).pipe(map(({ accountNonce }) => accountNonce));\n}\nfunction nextNonce(api, address) {\n    if (api.call.accountNonceApi) {\n        return api.call.accountNonceApi.accountNonce(address);\n    }\n    else {\n        return api.rpc.system?.accountNextIndex\n            ? api.rpc.system.accountNextIndex(address)\n            : latestNonce(api, address);\n    }\n}\nfunction signingHeader(api) {\n    return combineLatest([\n        api.rpc.chain.getHeader().pipe(switchMap((header) => \n        // check for chains at genesis (until block 1 is produced, e.g. 6s), since\n        // we do need to allow transactions at chain start (also dev/seal chains)\n        header.parentHash.isEmpty\n            ? of(header)\n            // in the case of the current block, we use the parent to minimize the\n            // impact of forks on the system, but not completely remove it\n            : api.rpc.chain.getHeader(header.parentHash).pipe(catchError(() => of(header))))),\n        api.rpc.chain.getFinalizedHead().pipe(switchMap((hash) => api.rpc.chain.getHeader(hash).pipe(catchError(() => of(null)))))\n    ]).pipe(map(([current, finalized]) => \n    // determine the hash to use, current when lag > max, else finalized\n    !finalized || unwrapBlockNumber(current).sub(unwrapBlockNumber(finalized)).gt(MAX_FINALITY_LAG)\n        ? current\n        : finalized));\n}\nfunction babeOrAuraPeriod(api) {\n    const period = api.consts.babe?.expectedBlockTime ||\n        // this will be present ones https://github.com/paritytech/polkadot-sdk/pull/3732 is merged\n        api.consts['aura']?.slotDuration ||\n        api.consts.timestamp?.minimumPeriod.muln(2);\n    return period && period.isZero && !period.isZero() ? period : undefined;\n}\nexport function signingInfo(_instanceId, api) {\n    // no memo, we want to do this fresh on each run\n    return (address, nonce, era) => combineLatest([\n        // retrieve nonce if none was specified\n        isUndefined(nonce)\n            ? latestNonce(api, address)\n            : nonce === -1\n                ? nextNonce(api, address)\n                : of(api.registry.createType('Index', nonce)),\n        // if no era (create) or era > 0 (mortal), do block retrieval\n        (isUndefined(era) || (isNumber(era) && era > 0))\n            ? signingHeader(api)\n            : of(null)\n    ]).pipe(map(([nonce, header]) => ({\n        header,\n        mortalLength: Math.min(api.consts.system?.blockHashCount?.toNumber() || FALLBACK_MAX_HASH_COUNT, MORTAL_PERIOD\n            .div(babeOrAuraPeriod(api) || FALLBACK_PERIOD)\n            .iadd(MAX_FINALITY_LAG)\n            .toNumber()),\n        nonce\n    })));\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
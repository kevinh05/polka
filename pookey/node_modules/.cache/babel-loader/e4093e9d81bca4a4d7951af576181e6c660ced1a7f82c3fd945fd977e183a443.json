{"ast":null,"code":"import { u8aEq } from '@polkadot/util';\nimport { jsonDecryptData } from '@polkadot/util-crypto';\nimport { PAIR_DIV, PAIR_HDR, PUB_LENGTH, SEC_LENGTH, SEED_LENGTH } from './defaults.js';\nconst SEED_OFFSET = PAIR_HDR.length;\n/**\n * Decode a pair, taking into account the generation-specific formats and headers\n *\n * For divisor/headers, don't rely on the magic being static. These will\n * change between generations, aka with the long-awaited 4th generation\n * of the format. The external decode interface is the only way to use and decode these.\n **/\nexport function decodePair(passphrase, encrypted, _encType) {\n  const encType = Array.isArray(_encType) || _encType === undefined ? _encType : [_encType];\n  const decrypted = jsonDecryptData(encrypted, passphrase, encType);\n  const header = decrypted.subarray(0, PAIR_HDR.length);\n  // check the start header (generations 1-3)\n  if (!u8aEq(header, PAIR_HDR)) {\n    throw new Error('Invalid encoding header found in body');\n  }\n  // setup for generation 3 format\n  let secretKey = decrypted.subarray(SEED_OFFSET, SEED_OFFSET + SEC_LENGTH);\n  let divOffset = SEED_OFFSET + SEC_LENGTH;\n  let divider = decrypted.subarray(divOffset, divOffset + PAIR_DIV.length);\n  // old-style (generation 1 & 2), we have the seed here\n  if (!u8aEq(divider, PAIR_DIV)) {\n    divOffset = SEED_OFFSET + SEED_LENGTH;\n    secretKey = decrypted.subarray(SEED_OFFSET, divOffset);\n    divider = decrypted.subarray(divOffset, divOffset + PAIR_DIV.length);\n    // check the divisior at this point (already checked for generation 3)\n    if (!u8aEq(divider, PAIR_DIV)) {\n      throw new Error('Invalid encoding divider found in body');\n    }\n  }\n  const pubOffset = divOffset + PAIR_DIV.length;\n  const publicKey = decrypted.subarray(pubOffset, pubOffset + PUB_LENGTH);\n  return {\n    publicKey,\n    secretKey\n  };\n}","map":{"version":3,"names":["u8aEq","jsonDecryptData","PAIR_DIV","PAIR_HDR","PUB_LENGTH","SEC_LENGTH","SEED_LENGTH","SEED_OFFSET","length","decodePair","passphrase","encrypted","_encType","encType","Array","isArray","undefined","decrypted","header","subarray","Error","secretKey","divOffset","divider","pubOffset","publicKey"],"sources":["C:/Users/khyy4/Documents/Code-Projects/polkahack/pookey/node_modules/@polkadot/api/node_modules/@polkadot/keyring/pair/decode.js"],"sourcesContent":["import { u8aEq } from '@polkadot/util';\nimport { jsonDecryptData } from '@polkadot/util-crypto';\nimport { PAIR_DIV, PAIR_HDR, PUB_LENGTH, SEC_LENGTH, SEED_LENGTH } from './defaults.js';\nconst SEED_OFFSET = PAIR_HDR.length;\n/**\n * Decode a pair, taking into account the generation-specific formats and headers\n *\n * For divisor/headers, don't rely on the magic being static. These will\n * change between generations, aka with the long-awaited 4th generation\n * of the format. The external decode interface is the only way to use and decode these.\n **/\nexport function decodePair(passphrase, encrypted, _encType) {\n    const encType = Array.isArray(_encType) || _encType === undefined\n        ? _encType\n        : [_encType];\n    const decrypted = jsonDecryptData(encrypted, passphrase, encType);\n    const header = decrypted.subarray(0, PAIR_HDR.length);\n    // check the start header (generations 1-3)\n    if (!u8aEq(header, PAIR_HDR)) {\n        throw new Error('Invalid encoding header found in body');\n    }\n    // setup for generation 3 format\n    let secretKey = decrypted.subarray(SEED_OFFSET, SEED_OFFSET + SEC_LENGTH);\n    let divOffset = SEED_OFFSET + SEC_LENGTH;\n    let divider = decrypted.subarray(divOffset, divOffset + PAIR_DIV.length);\n    // old-style (generation 1 & 2), we have the seed here\n    if (!u8aEq(divider, PAIR_DIV)) {\n        divOffset = SEED_OFFSET + SEED_LENGTH;\n        secretKey = decrypted.subarray(SEED_OFFSET, divOffset);\n        divider = decrypted.subarray(divOffset, divOffset + PAIR_DIV.length);\n        // check the divisior at this point (already checked for generation 3)\n        if (!u8aEq(divider, PAIR_DIV)) {\n            throw new Error('Invalid encoding divider found in body');\n        }\n    }\n    const pubOffset = divOffset + PAIR_DIV.length;\n    const publicKey = decrypted.subarray(pubOffset, pubOffset + PUB_LENGTH);\n    return {\n        publicKey,\n        secretKey\n    };\n}\n"],"mappings":"AAAA,SAASA,KAAK,QAAQ,gBAAgB;AACtC,SAASC,eAAe,QAAQ,uBAAuB;AACvD,SAASC,QAAQ,EAAEC,QAAQ,EAAEC,UAAU,EAAEC,UAAU,EAAEC,WAAW,QAAQ,eAAe;AACvF,MAAMC,WAAW,GAAGJ,QAAQ,CAACK,MAAM;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,UAAUA,CAACC,UAAU,EAAEC,SAAS,EAAEC,QAAQ,EAAE;EACxD,MAAMC,OAAO,GAAGC,KAAK,CAACC,OAAO,CAACH,QAAQ,CAAC,IAAIA,QAAQ,KAAKI,SAAS,GAC3DJ,QAAQ,GACR,CAACA,QAAQ,CAAC;EAChB,MAAMK,SAAS,GAAGhB,eAAe,CAACU,SAAS,EAAED,UAAU,EAAEG,OAAO,CAAC;EACjE,MAAMK,MAAM,GAAGD,SAAS,CAACE,QAAQ,CAAC,CAAC,EAAEhB,QAAQ,CAACK,MAAM,CAAC;EACrD;EACA,IAAI,CAACR,KAAK,CAACkB,MAAM,EAAEf,QAAQ,CAAC,EAAE;IAC1B,MAAM,IAAIiB,KAAK,CAAC,uCAAuC,CAAC;EAC5D;EACA;EACA,IAAIC,SAAS,GAAGJ,SAAS,CAACE,QAAQ,CAACZ,WAAW,EAAEA,WAAW,GAAGF,UAAU,CAAC;EACzE,IAAIiB,SAAS,GAAGf,WAAW,GAAGF,UAAU;EACxC,IAAIkB,OAAO,GAAGN,SAAS,CAACE,QAAQ,CAACG,SAAS,EAAEA,SAAS,GAAGpB,QAAQ,CAACM,MAAM,CAAC;EACxE;EACA,IAAI,CAACR,KAAK,CAACuB,OAAO,EAAErB,QAAQ,CAAC,EAAE;IAC3BoB,SAAS,GAAGf,WAAW,GAAGD,WAAW;IACrCe,SAAS,GAAGJ,SAAS,CAACE,QAAQ,CAACZ,WAAW,EAAEe,SAAS,CAAC;IACtDC,OAAO,GAAGN,SAAS,CAACE,QAAQ,CAACG,SAAS,EAAEA,SAAS,GAAGpB,QAAQ,CAACM,MAAM,CAAC;IACpE;IACA,IAAI,CAACR,KAAK,CAACuB,OAAO,EAAErB,QAAQ,CAAC,EAAE;MAC3B,MAAM,IAAIkB,KAAK,CAAC,wCAAwC,CAAC;IAC7D;EACJ;EACA,MAAMI,SAAS,GAAGF,SAAS,GAAGpB,QAAQ,CAACM,MAAM;EAC7C,MAAMiB,SAAS,GAAGR,SAAS,CAACE,QAAQ,CAACK,SAAS,EAAEA,SAAS,GAAGpB,UAAU,CAAC;EACvE,OAAO;IACHqB,SAAS;IACTJ;EACJ,CAAC;AACL","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
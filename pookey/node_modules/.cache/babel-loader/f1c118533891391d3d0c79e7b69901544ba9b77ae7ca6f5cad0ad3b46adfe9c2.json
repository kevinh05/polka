{"ast":null,"code":"import { __export } from \"./chunk-SMH5LAMQ.mjs\";\n\n// src/Address/index.ts\nvar Address_exports = {};\n__export(Address_exports, {\n  Address: () => Address,\n  algorithms: () => imports_exports,\n  collection: () => collection,\n  compare: () => compare,\n  constants: () => constants_exports,\n  extract: () => extract,\n  is: () => is,\n  mirror: () => mirror,\n  nesting: () => nesting,\n  normalize: () => normalize,\n  substrate: () => substrate,\n  validate: () => validate\n});\n\n// src/Address/constants.ts\nvar constants_exports = {};\n__export(constants_exports, {\n  COLLECTION_ADDRESS_PREFIX: () => COLLECTION_ADDRESS_PREFIX,\n  NESTING_PREFIX: () => NESTING_PREFIX,\n  STATIC_ADDRESSES: () => STATIC_ADDRESSES\n});\nvar STATIC_ADDRESSES = {\n  contractHelpers: \"0x842899ECF380553E8a4de75bF534cdf6fBF64049\",\n  collectionHelpers: \"0x6C4E9fE1AE37a41E93CEE429e8E1881aBdcbb54F\"\n};\nvar NESTING_PREFIX = \"0xf8238ccfff8ed887463fd5e0\";\nvar COLLECTION_ADDRESS_PREFIX = \"0x17c4e6453cc49aaaaeaca894e6d9683e\";\n\n// src/Address/imports.ts\nvar imports_exports = {};\n__export(imports_exports, {\n  base58: () => base58,\n  base64: () => base64,\n  basex: () => basex,\n  blake2b: () => blake2b,\n  keccak_256: () => keccak_256\n});\nimport basex from \"base-x\";\nimport { keccak_256 } from \"@noble/hashes/sha3\";\nimport { blake2b } from \"@noble/hashes/blake2b\";\nvar BASE58_ALPHABET = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\nvar BASE64_ALPHABET = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nvar base58 = basex(BASE58_ALPHABET);\nvar base64 = basex(BASE64_ALPHABET);\n\n// src/Address/ethereum.ts\nimport { HexString } from \"utf-helpers\";\nvar DWORDHexString = {\n  _checkU32: num => {\n    if (typeof num !== \"number\") throw new Error(`Passed number is not a number: ${typeof num}, ${num}`);\n    if (isNaN(num)) throw new Error(`Passed number is NaN: ${num}`);\n    if (num < 0) throw new Error(`Passed number is less than 0: ${num}`);\n    if (num > 4294967295) throw new Error(`Passed number is more than 2**32: ${num}`);\n    if (num !== Math.floor(num)) throw new Error(`Passed number is not an integer number: ${num}`);\n    return num;\n  },\n  fromNumber: n => {\n    return DWORDHexString._checkU32(n).toString(16).padStart(8, \"0\");\n  },\n  toNumber: s => {\n    const num = parseInt(s, 16);\n    if (isNaN(num)) throw new Error(`Passed string is not hexadecimal: ${s}`);\n    return DWORDHexString._checkU32(num);\n  }\n};\nvar unsafeNormalizeEthereumAddress = address => {\n  const addr = address.toLowerCase().replace(/^0x/i, \"\");\n  const addressHash = HexString.fromU8a(keccak_256(addr)).replace(/^0x/i, \"\");\n  let checksumAddress = \"0x\";\n  for (let i = 0; i < addr.length; i++) {\n    checksumAddress += parseInt(addressHash[i], 16) > 7 ? addr[i].toUpperCase() : addr[i];\n  }\n  return checksumAddress;\n};\nvar normalizeEthereumAddress = address => {\n  validate.ethereumAddress(address);\n  return unsafeNormalizeEthereumAddress(address);\n};\nvar compareEthereumAddresses = (address1, address2) => {\n  const addr1 = typeof address1 === \"string\" ? address1 : address1.Ethereum || address1.ethereum;\n  const addr2 = typeof address2 === \"string\" ? address2 : address2.Ethereum || address2.ethereum;\n  if (!addr1 || !addr2 || !is.ethereumAddress(addr1) || !is.ethereumAddress(addr2)) {\n    return false;\n  }\n  return addr1.toLowerCase() === addr2.toLowerCase();\n};\nvar collectionIdToEthAddress = collectionId => {\n  validate.collectionId(collectionId);\n  return unsafeNormalizeEthereumAddress(COLLECTION_ADDRESS_PREFIX + DWORDHexString.fromNumber(collectionId));\n};\nvar ethAddressToCollectionId = address => {\n  validate.collectionAddress(address);\n  return DWORDHexString.toNumber(address.slice(-8));\n};\nvar collectionIdAndTokenIdToNestingAddress = (collectionId, tokenId) => {\n  validate.collectionId(collectionId);\n  validate.tokenId(tokenId);\n  return unsafeNormalizeEthereumAddress(NESTING_PREFIX + DWORDHexString.fromNumber(collectionId) + DWORDHexString.fromNumber(tokenId));\n};\nvar nestingAddressToCollectionIdAndTokenId = address => {\n  validate.nestingAddress(address);\n  return {\n    collectionId: DWORDHexString.toNumber(address.slice(-16, -8)),\n    tokenId: DWORDHexString.toNumber(address.slice(-8))\n  };\n};\n\n// src/Address/substrate.ts\nimport { HexString as HexString2 } from \"utf-helpers\";\nvar blake2AsU8a = (u8a, dkLen = 32) => {\n  return blake2b(u8a, {\n    dkLen\n  });\n};\nvar u8aConcat = u8as => {\n  let offset = 0;\n  let length = 0;\n  for (let i = 0; i < u8as.length; i++) {\n    length += u8as[i].length;\n  }\n  const result = new Uint8Array(length);\n  for (let i = 0; i < u8as.length; i++) {\n    result.set(u8as[i], offset);\n    offset += u8as[i].length;\n  }\n  return result;\n};\nvar SS58_PREFIX = new Uint8Array([83, 83, 53, 56, 80, 82, 69]);\nvar sshash = data => {\n  return blake2AsU8a(u8aConcat([SS58_PREFIX, data]), 64);\n};\nvar checkAddressChecksum = (decoded, ignoreChecksum = false) => {\n  const ss58Length = decoded[0] & 64 ? 2 : 1;\n  const ss58Decoded = ss58Length === 1 ? decoded[0] : (decoded[0] & 63) << 2 | decoded[1] >> 6 | (decoded[1] & 63) << 8;\n  const isPublicKey = [34 + ss58Length, 35 + ss58Length].includes(decoded.length);\n  const length = decoded.length - (isPublicKey ? 2 : 1);\n  let isValid = false;\n  if (!ignoreChecksum) {\n    const hash = sshash(decoded.subarray(0, length));\n    isValid = (decoded[0] & 128) === 0 && ![46, 47].includes(decoded[0]) && (isPublicKey ? decoded[decoded.length - 2] === hash[0] && decoded[decoded.length - 1] === hash[1] : decoded[decoded.length - 1] === hash[0]);\n  }\n  return [isValid, length, ss58Length, ss58Decoded];\n};\nvar normalizeSubstrateAddress = (address, prefix = 42) => {\n  return encodeSubstrateAddress(decodeSubstrateAddress(address).u8a, prefix);\n};\nfunction encodeSubstrateAddress(key, ss58Format = 42) {\n  const u8a = typeof key === \"string\" ? HexString2.toU8a(key) : typeof key === \"bigint\" ? HexString2.toU8a(key.toString(16)) : key;\n  if (ss58Format < 0 || ss58Format > 16383 || [46, 47].includes(ss58Format)) {\n    throw new Error(`ss58Format is not valid, received ${typeof ss58Format} \"${ss58Format}\"`);\n  }\n  const allowedDecodedLengths = [1, 2, 4, 8, 32, 33];\n  if (!allowedDecodedLengths.includes(u8a.length)) {\n    throw new Error(`key length is not valid, received ${u8a.length}, valid values are ${allowedDecodedLengths.join(\", \")}`);\n  }\n  const u8aPrefix = ss58Format < 64 ? new Uint8Array([ss58Format]) : new Uint8Array([(ss58Format & 252) >> 2 | 64, ss58Format >> 8 | (ss58Format & 3) << 6]);\n  const input = u8aConcat([u8aPrefix, u8a]);\n  return base58.encode(u8aConcat([input, sshash(input).subarray(0, [32, 33].includes(u8a.length) ? 2 : 1)]));\n}\nfunction decodeSubstrateAddress(address, ignoreChecksum, ss58Format = -1) {\n  let realError = null;\n  try {\n    if (is.substratePublicKey(address)) {\n      return {\n        u8a: HexString2.toU8a(address),\n        bigint: BigInt(address),\n        hex: address,\n        ss58Prefix: 42\n      };\n    } else if (address.startsWith(\"0x\")) {\n      throw new Error(`Invalid substrate address, received ${address}. Wrong or mangled public key?`);\n    }\n    const decoded = base58.decode(address);\n    const allowedEncodedLengths = [3, 4, 6, 10, 35, 36, 37, 38];\n    if (!allowedEncodedLengths.includes(decoded.length)) {\n      realError = new Error(`key length is not valid, decoded key length is ${decoded.length}, valid values are ${allowedEncodedLengths.join(\", \")}`);\n      throw realError;\n    }\n    const [isValid, endPos, ss58Length, ss58Decoded] = checkAddressChecksum(decoded, ignoreChecksum);\n    if (!ignoreChecksum && !isValid) {\n      realError = new Error(`Invalid decoded address checksum`);\n      throw realError;\n    }\n    if (![-1, ss58Decoded].includes(ss58Format)) {\n      realError = new Error(`Expected ss58Format ${ss58Format}, received ${ss58Decoded}`);\n      throw realError;\n    }\n    const publicKey = decoded.slice(ss58Length, endPos);\n    const hex = HexString2.fromU8a(publicKey);\n    return {\n      u8a: publicKey,\n      hex,\n      bigint: BigInt(hex),\n      ss58Prefix: ss58Decoded\n    };\n  } catch (error) {\n    throw realError ? realError : new Error(`Decoding ${address}: ${error.message}`);\n  }\n}\nvar compareSubstrateAddresses = (address1, address2) => {\n  const addr1 = typeof address1 === \"string\" ? address1 : address1.Substrate || address1.substrate;\n  const addr2 = typeof address2 === \"string\" ? address2 : address2.Substrate || address2.substrate;\n  if (!addr1 || !addr2) {\n    return false;\n  }\n  try {\n    const decoded1 = decodeSubstrateAddress(addr1);\n    const decoded2 = decodeSubstrateAddress(addr2);\n    return decoded1.bigint === decoded2.bigint;\n  } catch (e) {\n    return false;\n  }\n};\nvar addressToEvm = (address, ignoreChecksum) => {\n  const truncated = decodeSubstrateAddress(address, ignoreChecksum).u8a.subarray(0, 20);\n  return normalizeEthereumAddress(HexString2.fromU8a(truncated));\n};\nvar EVM_PREFIX_U8A = new Uint8Array([101, 118, 109, 58]);\nvar evmToAddress = (evmAddress, ss58Format = 42) => {\n  validate.ethereumAddress(evmAddress);\n  const message = u8aConcat([EVM_PREFIX_U8A, HexString2.toU8a(evmAddress)]);\n  return encodeSubstrateAddress(blake2AsU8a(message), ss58Format);\n};\n\n// src/Address/crossAccountId.ts\nvar guessAddressAndExtractCrossAccountIdUnsafe = (rawAddress, normalize2 = false) => {\n  const address = rawAddress;\n  if (typeof address === \"object\") {\n    if (address.hasOwnProperty(\"eth\") && address.hasOwnProperty(\"sub\")) {\n      const subPublicKey = address.sub.hasOwnProperty(\"_hex\") && typeof address.sub._hex === \"string\" ? address.sub._hex : address.sub;\n      if (typeof subPublicKey !== \"string\" || !subPublicKey.startsWith(\"0x\")) {\n        throw new Error(`Substrate public key must be a hex string, got ${subPublicKey}`);\n      }\n      const subBigInt = BigInt(subPublicKey);\n      const ethBigInt = BigInt(address.eth);\n      if (!(Number(subBigInt === 0n) ^ Number(ethBigInt === 0n))) {\n        throw new Error(`One of the addresses must be 0, got eth ${address.eth} and substrate public key ${address.sub}.`);\n      }\n      if (subBigInt === 0n) {\n        return {\n          Ethereum: normalizeEthereumAddress(address.eth)\n        };\n      } else {\n        return {\n          Substrate: normalizeSubstrateAddress(subPublicKey)\n        };\n      }\n    } else if (address.hasOwnProperty(\"Substrate\") || address.hasOwnProperty(\"substrate\")) {\n      const substrateAddress = address.hasOwnProperty(\"Substrate\") ? address.Substrate : address.substrate;\n      if (is.substratePublicKey(substrateAddress)) {\n        return {\n          Substrate: normalizeSubstrateAddress(substrateAddress)\n        };\n      } else if (is.substrateAddress(substrateAddress)) {\n        return {\n          Substrate: normalize2 ? normalizeSubstrateAddress(substrateAddress) : substrateAddress\n        };\n      } else {\n        throw new Error(`Address ${substrateAddress} is not a valid Substrate address`);\n      }\n    } else if (address.hasOwnProperty(\"Ethereum\") || address.hasOwnProperty(\"ethereum\")) {\n      const ethereumAddress = address.hasOwnProperty(\"Ethereum\") ? address.Ethereum : address.ethereum;\n      validate.ethereumAddress(ethereumAddress);\n      return {\n        Ethereum: normalize2 ? normalizeEthereumAddress(ethereumAddress) : ethereumAddress\n      };\n    } else {\n      throw new Error(`Address ${address} is not a valid crossAccountId object (should contain \"Substrate\"/\"substrate\" or \"Ethereum\"/\"ethereum\" field) or EthCrossAccountId (should contain \"eth\" and \"sub\" fields)`);\n    }\n  }\n  if (typeof address === \"string\") {\n    if (is.substrateAddress(address)) return {\n      Substrate: normalize2 ? normalizeSubstrateAddress(address) : address\n    };else if (is.ethereumAddress(address)) return {\n      Ethereum: normalize2 ? normalizeEthereumAddress(address) : address\n    };else if (is.substratePublicKey(address)) return {\n      Substrate: normalizeSubstrateAddress(address)\n    };else {\n      throw new Error(`Address ${address} is not a valid Substrate or Ethereum address`);\n    }\n  }\n  throw new Error(`Address ${address} is not a string or object: ${typeof address}`);\n};\nvar guessAddressAndExtractCrossAccountIdSafe = (address, normalize2 = false) => {\n  try {\n    return guessAddressAndExtractCrossAccountIdUnsafe(address, normalize2);\n  } catch {\n    return null;\n  }\n};\nvar substrateOrMirrorIfEthereum = (address, normalize2 = false) => {\n  const addressObject = guessAddressAndExtractCrossAccountIdUnsafe(address, normalize2);\n  return addressObject.Substrate ? addressObject.Substrate : mirror.ethereumToSubstrate(addressObject.Ethereum);\n};\nvar addressInAnyFormToEnhancedCrossAccountId = (address, ss58Prefix = 42) => {\n  const crossAccountId = guessAddressAndExtractCrossAccountIdUnsafe(address);\n  if (crossAccountId.Ethereum) {\n    const normalized = normalizeEthereumAddress(crossAccountId.Ethereum);\n    return {\n      ...crossAccountId,\n      address: normalized,\n      addressSS58: normalized,\n      substratePublicKey: normalized,\n      isEthereum: true,\n      isSubstrate: false,\n      type: \"Ethereum\"\n    };\n  } else {\n    return {\n      ...crossAccountId,\n      address: normalizeSubstrateAddress(crossAccountId.Substrate),\n      addressSS58: normalizeSubstrateAddress(crossAccountId.Substrate, ss58Prefix),\n      substratePublicKey: decodeSubstrateAddress(crossAccountId.Substrate).hex,\n      isEthereum: false,\n      isSubstrate: true,\n      type: \"Substrate\"\n    };\n  }\n};\n\n// src/Address/index.ts\nvar ETH_ADDRESS_REGEX = /^0x[a-fA-F0-9]{40}$/;\nvar SUB_PUBLIC_KEY_REGEX = /^0x[a-fA-F0-9]{64}$/;\nvar validate = {\n  substrateAddress: address => {\n    decodeSubstrateAddress(address);\n    return true;\n  },\n  ethereumAddress: address => {\n    if (!is.ethereumAddress(address)) {\n      throw new Error(`address \"${address}\" is not valid ethereum address`);\n    }\n    return true;\n  },\n  substratePublicKey: address => {\n    if (!is.substratePublicKey(address)) {\n      throw new Error(`address \"${address}\" is not valid substrate public key`);\n    }\n    return true;\n  },\n  collectionAddress: address => {\n    if (!is.collectionAddress(address)) {\n      throw new Error(`address ${address} is not a collection address`);\n    }\n    return true;\n  },\n  nestingAddress: address => {\n    if (!is.nestingAddress(address)) {\n      throw new Error(`address ${address} is not a nesting address`);\n    }\n    return true;\n  },\n  collectionId: collectionId => {\n    if (!is.collectionId(collectionId)) {\n      throw new Error(`collectionId should be a number between 0 and 0xffffffff`);\n    }\n    return true;\n  },\n  tokenId: tokenId => {\n    if (!is.tokenId(tokenId)) {\n      throw new Error(`collectionId should be a number between 0 and 0xffffffff`);\n    }\n    return true;\n  }\n};\nvar is = {\n  substrateAddress: address => {\n    try {\n      decodeSubstrateAddress(address);\n      return !is.substratePublicKey(address);\n    } catch {\n      return false;\n    }\n  },\n  ethereumAddress: address => {\n    return typeof address === \"string\" && address.length === 42 && !!address.match(ETH_ADDRESS_REGEX);\n  },\n  substratePublicKey: address => {\n    return typeof address === \"string\" && address.length === 66 && !!address.match(SUB_PUBLIC_KEY_REGEX);\n  },\n  collectionAddress: address => {\n    return is.ethereumAddress(address) && address.toLowerCase().startsWith(COLLECTION_ADDRESS_PREFIX);\n  },\n  nestingAddress: address => {\n    return is.ethereumAddress(address) && address.toLowerCase().startsWith(NESTING_PREFIX);\n  },\n  collectionId: collectionId => {\n    return !(typeof collectionId !== \"number\" || isNaN(collectionId) || collectionId < 0 || collectionId > 4294967295);\n  },\n  tokenId: tokenId => {\n    return !(typeof tokenId !== \"number\" || isNaN(tokenId) || tokenId < 0 || tokenId > 4294967295);\n  },\n  crossAccountId(obj) {\n    return is.substrateAddressObject(obj) || is.ethereumAddressObject(obj);\n  },\n  crossAccountIdUncapitalized(obj) {\n    return is.substrateAddressObjectUncapitalized(obj) || is.ethereumAddressObjectUncapitalized(obj);\n  },\n  substrateAddressObject(obj) {\n    return typeof obj === \"object\" && typeof obj?.Substrate === \"string\" && is.substrateAddress(obj.Substrate);\n  },\n  ethereumAddressObject(obj) {\n    return typeof obj === \"object\" && typeof obj?.Ethereum === \"string\" && is.ethereumAddress(obj.Ethereum);\n  },\n  substrateAddressObjectUncapitalized(obj) {\n    return typeof obj === \"object\" && typeof obj?.substrate === \"string\" && is.substrateAddress(obj.substrate);\n  },\n  ethereumAddressObjectUncapitalized(obj) {\n    return typeof obj === \"object\" && typeof obj?.ethereum === \"string\" && is.ethereumAddress(obj.ethereum);\n  },\n  substrateAddressInAnyForm(address) {\n    return typeof address === \"string\" ? is.substrateAddress(address) : typeof address === \"object\" && !!address && (is.substrateAddressObject(address) || is.substrateAddressObjectUncapitalized(address));\n  },\n  ethereumAddressInAnyForm(address) {\n    return typeof address === \"string\" ? is.ethereumAddress(address) : typeof address === \"object\" && !!address && (is.ethereumAddressObject(address) || is.ethereumAddressObjectUncapitalized(address));\n  },\n  validAddressInAnyForm(address) {\n    return is.ethereumAddressInAnyForm(address) || is.substrateAddressInAnyForm(address);\n  }\n};\nvar collection = {\n  idToAddress: collectionIdToEthAddress,\n  addressToId: ethAddressToCollectionId\n};\nvar nesting = {\n  idsToAddress: collectionIdAndTokenIdToNestingAddress,\n  addressToIds: nestingAddressToCollectionIdAndTokenId\n};\nvar extract = {\n  address: addressOrCrossAccountId => {\n    const crossAccountId = guessAddressAndExtractCrossAccountIdUnsafe(addressOrCrossAccountId);\n    return crossAccountId.Substrate || crossAccountId.Ethereum;\n  },\n  addressSafe: addressOrCrossAccountId => {\n    const crossAccountId = guessAddressAndExtractCrossAccountIdSafe(addressOrCrossAccountId);\n    return crossAccountId ? crossAccountId.Substrate || crossAccountId.Ethereum : null;\n  },\n  addressNormalized: addressOrCrossAccountId => {\n    const crossAccountId = guessAddressAndExtractCrossAccountIdUnsafe(addressOrCrossAccountId, true);\n    return crossAccountId.Substrate || crossAccountId.Ethereum;\n  },\n  addressNormalizedSafe: addressOrCrossAccountId => {\n    const crossAccountId = guessAddressAndExtractCrossAccountIdSafe(addressOrCrossAccountId, true);\n    return crossAccountId ? crossAccountId.Substrate || crossAccountId.Ethereum : null;\n  },\n  addressForScanNormalized: addressOrCrossAccountId => {\n    const crossAccountId = guessAddressAndExtractCrossAccountIdUnsafe(addressOrCrossAccountId, true);\n    return crossAccountId.Substrate || crossAccountId.Ethereum.toLowerCase();\n  },\n  addressForScanNormalizedSafe: addressOrCrossAccountId => {\n    const crossAccountId = guessAddressAndExtractCrossAccountIdSafe(addressOrCrossAccountId, true);\n    return crossAccountId ? crossAccountId.Substrate || crossAccountId.Ethereum.toLowerCase() : null;\n  },\n  crossAccountId: addressOrCrossAccountId => {\n    return guessAddressAndExtractCrossAccountIdUnsafe(addressOrCrossAccountId);\n  },\n  crossAccountIdSafe: addressOrCrossAccountId => {\n    return guessAddressAndExtractCrossAccountIdSafe(addressOrCrossAccountId);\n  },\n  crossAccountIdNormalized: addressOrCrossAccountId => {\n    return guessAddressAndExtractCrossAccountIdUnsafe(addressOrCrossAccountId, true);\n  },\n  crossAccountIdNormalizedSafe: addressOrCrossAccountId => {\n    return guessAddressAndExtractCrossAccountIdSafe(addressOrCrossAccountId, true);\n  },\n  crossAccountIdUncapitalized: addressOrCrossAccountId => {\n    const crossAccountId = guessAddressAndExtractCrossAccountIdUnsafe(addressOrCrossAccountId);\n    return crossAccountId.Substrate ? {\n      substrate: crossAccountId.Substrate\n    } : {\n      ethereum: crossAccountId.Ethereum\n    };\n  },\n  crossAccountIdUncapitalizedSafe: addressOrCrossAccountId => {\n    try {\n      return extract.crossAccountIdUncapitalized(addressOrCrossAccountId);\n    } catch {\n      return null;\n    }\n  },\n  crossAccountIdUncapitalizedNormalized: addressOrCrossAccountId => {\n    const crossAccountId = guessAddressAndExtractCrossAccountIdUnsafe(addressOrCrossAccountId, true);\n    return crossAccountId.Substrate ? {\n      substrate: crossAccountId.Substrate\n    } : {\n      ethereum: crossAccountId.Ethereum\n    };\n  },\n  crossAccountIdUncapitalizedNormalizedSafe: addressOrCrossAccountId => {\n    try {\n      return extract.crossAccountIdUncapitalizedNormalized(addressOrCrossAccountId);\n    } catch {\n      return null;\n    }\n  },\n  substrateOrMirrorIfEthereum: addressOrCrossAccountId => {\n    return substrateOrMirrorIfEthereum(addressOrCrossAccountId);\n  },\n  substrateOrMirrorIfEthereumSafe: addressOrCrossAccountId => {\n    try {\n      return substrateOrMirrorIfEthereum(addressOrCrossAccountId);\n    } catch {\n      return null;\n    }\n  },\n  substrateOrMirrorIfEthereumNormalized: addressOrCrossAccountId => {\n    return substrateOrMirrorIfEthereum(addressOrCrossAccountId, true);\n  },\n  substrateOrMirrorIfEthereumNormalizedSafe: addressOrCrossAccountId => {\n    try {\n      return substrateOrMirrorIfEthereum(addressOrCrossAccountId, true);\n    } catch {\n      return null;\n    }\n  },\n  substratePublicKey: addressOrCrossAccountId => {\n    const crossAccountId = guessAddressAndExtractCrossAccountIdUnsafe(addressOrCrossAccountId);\n    if (!crossAccountId.Substrate) {\n      throw new Error(\"Address is not a substrate address\");\n    }\n    return substrate.decode(crossAccountId.Substrate).hex;\n  },\n  substratePublicKeySafe: addressOrCrossAccountId => {\n    try {\n      return extract.substratePublicKey(addressOrCrossAccountId);\n    } catch {\n      return null;\n    }\n  },\n  enhancedCrossAccountId: (addressInAnyForm, ss58Prefix = 42) => {\n    return addressInAnyFormToEnhancedCrossAccountId(addressInAnyForm, ss58Prefix);\n  },\n  enhancedCrossAccountIdSafe: (addressInAnyForm, ss58Prefix = 42) => {\n    try {\n      return addressInAnyFormToEnhancedCrossAccountId(addressInAnyForm, ss58Prefix);\n    } catch {\n      return null;\n    }\n  },\n  ethCrossAccountId: addressInAnyForm => {\n    const addressEnhanced = addressInAnyFormToEnhancedCrossAccountId(addressInAnyForm);\n    if (addressEnhanced.Substrate) {\n      return {\n        eth: \"0x0000000000000000000000000000000000000000\",\n        sub: addressEnhanced.substratePublicKey\n      };\n    } else {\n      return {\n        eth: addressEnhanced.address,\n        sub: \"0x00\"\n      };\n    }\n  },\n  ethCrossAccountIdSafe: addressInAnyForm => {\n    try {\n      return extract.ethCrossAccountId(addressInAnyForm);\n    } catch {\n      return null;\n    }\n  }\n};\nvar mirror = {\n  substrateToEthereum: addressToEvm,\n  ethereumToSubstrate: evmToAddress\n};\nvar normalize = {\n  substrateAddress: normalizeSubstrateAddress,\n  ethereumAddress: normalizeEthereumAddress\n};\nvar compare = {\n  substrateAddresses: compareSubstrateAddresses,\n  ethereumAddresses: compareEthereumAddresses\n};\nvar substrate = {\n  encode: encodeSubstrateAddress,\n  decode: decodeSubstrateAddress,\n  compare: compareSubstrateAddresses\n};\nvar Address = {\n  constants: constants_exports,\n  algorithms: imports_exports,\n  is,\n  validate,\n  collection,\n  nesting,\n  extract,\n  mirror,\n  normalize,\n  compare,\n  substrate,\n  utils: {\n    DWORDHexString\n  }\n};\nexport { constants_exports, imports_exports, validate, is, collection, nesting, extract, mirror, normalize, compare, substrate, Address, Address_exports };","map":{"version":3,"names":["Address_exports","__export","Address","algorithms","imports_exports","collection","compare","constants","constants_exports","extract","is","mirror","nesting","normalize","substrate","validate","COLLECTION_ADDRESS_PREFIX","NESTING_PREFIX","STATIC_ADDRESSES","contractHelpers","collectionHelpers","base58","base64","basex","blake2b","keccak_256","BASE58_ALPHABET","BASE64_ALPHABET","HexString","DWORDHexString","_checkU32","num","Error","isNaN","Math","floor","fromNumber","n","toString","padStart","toNumber","s","parseInt","unsafeNormalizeEthereumAddress","address","addr","toLowerCase","replace","addressHash","fromU8a","checksumAddress","i","length","toUpperCase","normalizeEthereumAddress","ethereumAddress","compareEthereumAddresses","address1","address2","addr1","Ethereum","ethereum","addr2","collectionIdToEthAddress","collectionId","ethAddressToCollectionId","collectionAddress","slice","collectionIdAndTokenIdToNestingAddress","tokenId","nestingAddressToCollectionIdAndTokenId","nestingAddress","HexString2","blake2AsU8a","u8a","dkLen","u8aConcat","u8as","offset","result","Uint8Array","set","SS58_PREFIX","sshash","data","checkAddressChecksum","decoded","ignoreChecksum","ss58Length","ss58Decoded","isPublicKey","includes","isValid","hash","subarray","normalizeSubstrateAddress","prefix","encodeSubstrateAddress","decodeSubstrateAddress","key","ss58Format","toU8a","allowedDecodedLengths","join","u8aPrefix","input","encode","realError","substratePublicKey","bigint","BigInt","hex","ss58Prefix","startsWith","decode","allowedEncodedLengths","endPos","publicKey","error","message","compareSubstrateAddresses","Substrate","decoded1","decoded2","e","addressToEvm","truncated","EVM_PREFIX_U8A","evmToAddress","evmAddress","guessAddressAndExtractCrossAccountIdUnsafe","rawAddress","normalize2","hasOwnProperty","subPublicKey","sub","_hex","subBigInt","ethBigInt","eth","Number","substrateAddress","guessAddressAndExtractCrossAccountIdSafe","substrateOrMirrorIfEthereum","addressObject","ethereumToSubstrate","addressInAnyFormToEnhancedCrossAccountId","crossAccountId","normalized","addressSS58","isEthereum","isSubstrate","type","ETH_ADDRESS_REGEX","SUB_PUBLIC_KEY_REGEX","match","obj","substrateAddressObject","ethereumAddressObject","crossAccountIdUncapitalized","substrateAddressObjectUncapitalized","ethereumAddressObjectUncapitalized","substrateAddressInAnyForm","ethereumAddressInAnyForm","validAddressInAnyForm","idToAddress","addressToId","idsToAddress","addressToIds","addressOrCrossAccountId","addressSafe","addressNormalized","addressNormalizedSafe","addressForScanNormalized","addressForScanNormalizedSafe","crossAccountIdSafe","crossAccountIdNormalized","crossAccountIdNormalizedSafe","crossAccountIdUncapitalizedSafe","crossAccountIdUncapitalizedNormalized","crossAccountIdUncapitalizedNormalizedSafe","substrateOrMirrorIfEthereumSafe","substrateOrMirrorIfEthereumNormalized","substrateOrMirrorIfEthereumNormalizedSafe","substratePublicKeySafe","enhancedCrossAccountId","addressInAnyForm","enhancedCrossAccountIdSafe","ethCrossAccountId","addressEnhanced","ethCrossAccountIdSafe","substrateToEthereum","substrateAddresses","ethereumAddresses","utils"],"sources":["C:\\Users\\khyy4\\Documents\\Code-Projects\\polkahack\\pookey\\node_modules\\@unique-nft\\src\\Address\\index.ts","C:\\Users\\khyy4\\Documents\\Code-Projects\\polkahack\\pookey\\node_modules\\@unique-nft\\src\\Address\\constants.ts","C:\\Users\\khyy4\\Documents\\Code-Projects\\polkahack\\pookey\\node_modules\\@unique-nft\\src\\Address\\imports.ts","C:\\Users\\khyy4\\Documents\\Code-Projects\\polkahack\\pookey\\node_modules\\@unique-nft\\src\\Address\\ethereum.ts","C:\\Users\\khyy4\\Documents\\Code-Projects\\polkahack\\pookey\\node_modules\\@unique-nft\\src\\Address\\substrate.ts","C:\\Users\\khyy4\\Documents\\Code-Projects\\polkahack\\pookey\\node_modules\\@unique-nft\\src\\Address\\crossAccountId.ts"],"sourcesContent":["import {COLLECTION_ADDRESS_PREFIX, NESTING_PREFIX} from './constants'\n\nimport {\n  addressToEvm, compareSubstrateAddresses,\n  decodeSubstrateAddress, encodeSubstrateAddress,\n  evmToAddress,\n  normalizeSubstrateAddress\n} from './substrate'\n\nimport {\n  collectionIdAndTokenIdToNestingAddress,\n  collectionIdToEthAddress, compareEthereumAddresses, DWORDHexString,\n  ethAddressToCollectionId,\n  nestingAddressToCollectionIdAndTokenId,\n  normalizeEthereumAddress\n} from './ethereum'\nimport {\n  CrossAccountId, CrossAccountIdUncapitalized,\n  EthAddressObj, EthAddressObjUncapitalized,\n  SubAddressObj, SubAddressObjUncapitalized,\n  EnhancedCrossAccountId, EthCrossAccountId,\n} from '../types'\nimport {\n  addressInAnyFormToEnhancedCrossAccountId,\n  guessAddressAndExtractCrossAccountIdSafe,\n  guessAddressAndExtractCrossAccountIdUnsafe,\n  substrateOrMirrorIfEthereum\n} from './crossAccountId'\n\nimport * as algorithms from './imports'\nimport * as constants from './constants'\n\nexport {constants, algorithms}\n\nconst ETH_ADDRESS_REGEX = /^0x[a-fA-F0-9]{40}$/\nconst SUB_PUBLIC_KEY_REGEX = /^0x[a-fA-F0-9]{64}$/\n\nexport type DecodeSubstrateAddressResult = {\n  u8a: Uint8Array\n  hex: string\n  bigint: bigint\n  ss58Prefix: number\n}\n\nexport const validate = {\n  substrateAddress: (address: string) => {\n    decodeSubstrateAddress(address)\n    return true\n  },\n  ethereumAddress: (address: string) => {\n    if (!is.ethereumAddress(address)) {\n      throw new Error(`address \"${address}\" is not valid ethereum address`)\n    }\n    return true\n  },\n  substratePublicKey: (address: string) => {\n    if (!is.substratePublicKey(address)) {\n      throw new Error(`address \"${address}\" is not valid substrate public key`)\n    }\n    return true\n  },\n  collectionAddress: (address: string) => {\n    if (!is.collectionAddress(address)) {\n      throw new Error(`address ${address} is not a collection address`)\n    }\n    return true\n  },\n  nestingAddress: (address: string) => {\n    if (!is.nestingAddress(address)) {\n      throw new Error(`address ${address} is not a nesting address`)\n    }\n    return true\n  },\n  collectionId: (collectionId: number) => {\n    if (!is.collectionId(collectionId)) {\n      throw new Error(`collectionId should be a number between 0 and 0xffffffff`)\n    }\n    return true\n  },\n  tokenId: (tokenId: number) => {\n    if (!is.tokenId(tokenId)) {\n      throw new Error(`collectionId should be a number between 0 and 0xffffffff`)\n    }\n    return true\n  },\n}\n\nexport const is = {\n  substrateAddress: (address: string): boolean => {\n    try {\n      decodeSubstrateAddress(address)\n      return !is.substratePublicKey(address)\n    } catch {\n      return false\n    }\n  },\n  ethereumAddress: (address: string): boolean => {\n    return typeof address === 'string' && address.length === 42 && !!address.match(ETH_ADDRESS_REGEX)\n  },\n  substratePublicKey: (address: string): boolean => {\n    return typeof address === 'string' && address.length === 66 && !!address.match(SUB_PUBLIC_KEY_REGEX)\n  },\n\n  collectionAddress: (address: string): boolean => {\n    return is.ethereumAddress(address) && address.toLowerCase().startsWith(COLLECTION_ADDRESS_PREFIX)\n  },\n  nestingAddress: (address: string): boolean => {\n    return is.ethereumAddress(address) && address.toLowerCase().startsWith(NESTING_PREFIX)\n  },\n\n  collectionId: (collectionId: number): boolean => {\n    return !(typeof collectionId !== 'number' || isNaN(collectionId) || collectionId < 0 || collectionId > 0xffffffff)\n  },\n  tokenId: (tokenId: number): boolean => {\n    return !(typeof tokenId !== 'number' || isNaN(tokenId) || tokenId < 0 || tokenId > 0xffffffff)\n  },\n\n  crossAccountId(obj: any): obj is CrossAccountId {\n    return is.substrateAddressObject(obj) || is.ethereumAddressObject(obj)\n  },\n  crossAccountIdUncapitalized(obj: any): obj is CrossAccountIdUncapitalized {\n    return is.substrateAddressObjectUncapitalized(obj) || is.ethereumAddressObjectUncapitalized(obj)\n  },\n  substrateAddressObject(obj: any): obj is SubAddressObj {\n    return typeof obj === 'object' && typeof obj?.Substrate === 'string' && is.substrateAddress(obj.Substrate)\n  },\n  ethereumAddressObject(obj: any): obj is EthAddressObj {\n    return typeof obj === 'object' && typeof obj?.Ethereum === 'string' && is.ethereumAddress(obj.Ethereum)\n  },\n  substrateAddressObjectUncapitalized(obj: any): obj is SubAddressObjUncapitalized {\n    return typeof obj === 'object' && typeof obj?.substrate === 'string' && is.substrateAddress(obj.substrate)\n  },\n  ethereumAddressObjectUncapitalized(obj: any): obj is EthAddressObjUncapitalized {\n    return typeof obj === 'object' && typeof obj?.ethereum === 'string' && is.ethereumAddress(obj.ethereum)\n  },\n  substrateAddressInAnyForm(address: any): address is string | SubAddressObj | SubAddressObjUncapitalized {\n    return typeof address === 'string'\n      ? is.substrateAddress(address)\n      : (\n        typeof address === 'object' &&\n        !!address &&\n        (is.substrateAddressObject(address) || is.substrateAddressObjectUncapitalized(address))\n      )\n  },\n  ethereumAddressInAnyForm(address: any): address is string | EthAddressObj | EthAddressObjUncapitalized {\n    return typeof address === 'string'\n      ? is.ethereumAddress(address)\n      : (\n        typeof address === 'object' &&\n        !!address &&\n        (is.ethereumAddressObject(address) || is.ethereumAddressObjectUncapitalized(address))\n      )\n  },\n  validAddressInAnyForm(address: any): address is string | SubAddressObj | SubAddressObjUncapitalized | EthAddressObj | EthAddressObjUncapitalized {\n    return is.ethereumAddressInAnyForm(address) || is.substrateAddressInAnyForm(address)\n  }\n}\n\nexport const collection = {\n  idToAddress: collectionIdToEthAddress,\n  addressToId: ethAddressToCollectionId,\n}\nexport const nesting = {\n  idsToAddress: collectionIdAndTokenIdToNestingAddress,\n  addressToIds: nestingAddressToCollectionIdAndTokenId,\n}\n\nexport const extract = {\n  address: (addressOrCrossAccountId: string | object): string => {\n    const crossAccountId = guessAddressAndExtractCrossAccountIdUnsafe(addressOrCrossAccountId)\n    return (crossAccountId.Substrate || crossAccountId.Ethereum) as string\n  },\n  addressSafe: (addressOrCrossAccountId: string | object): string | null => {\n    const crossAccountId = guessAddressAndExtractCrossAccountIdSafe(addressOrCrossAccountId)\n    return crossAccountId ? (crossAccountId.Substrate || crossAccountId.Ethereum) as string : null\n  },\n\n  addressNormalized: (addressOrCrossAccountId: string | object): string => {\n    const crossAccountId = guessAddressAndExtractCrossAccountIdUnsafe(addressOrCrossAccountId, true)\n    return (crossAccountId.Substrate || crossAccountId.Ethereum) as string\n  },\n  addressNormalizedSafe: (addressOrCrossAccountId: string | object): string | null => {\n    const crossAccountId = guessAddressAndExtractCrossAccountIdSafe(addressOrCrossAccountId, true)\n    return crossAccountId ? (crossAccountId.Substrate || crossAccountId.Ethereum) as string : null\n  },\n\n  addressForScanNormalized: (addressOrCrossAccountId: string | object): string => {\n    const crossAccountId = guessAddressAndExtractCrossAccountIdUnsafe(addressOrCrossAccountId, true)\n    return (crossAccountId.Substrate || crossAccountId.Ethereum!.toLowerCase()) as string\n  },\n  addressForScanNormalizedSafe: (addressOrCrossAccountId: string | object): string | null => {\n    const crossAccountId = guessAddressAndExtractCrossAccountIdSafe(addressOrCrossAccountId, true)\n    return crossAccountId ? (crossAccountId.Substrate || crossAccountId.Ethereum!.toLowerCase()) as string : null\n  },\n\n\n  crossAccountId: (addressOrCrossAccountId: string | object): CrossAccountId => {\n    return guessAddressAndExtractCrossAccountIdUnsafe(addressOrCrossAccountId)\n  },\n  crossAccountIdSafe: (addressOrCrossAccountId: string | object): CrossAccountId | null => {\n    return guessAddressAndExtractCrossAccountIdSafe(addressOrCrossAccountId)\n  },\n\n  crossAccountIdNormalized: (addressOrCrossAccountId: string | object): CrossAccountId => {\n    return guessAddressAndExtractCrossAccountIdUnsafe(addressOrCrossAccountId, true)\n  },\n  crossAccountIdNormalizedSafe: (addressOrCrossAccountId: string | object): CrossAccountId | null => {\n    return guessAddressAndExtractCrossAccountIdSafe(addressOrCrossAccountId, true)\n  },\n\n  crossAccountIdUncapitalized: (addressOrCrossAccountId: string | object): CrossAccountIdUncapitalized => {\n    const crossAccountId = guessAddressAndExtractCrossAccountIdUnsafe(addressOrCrossAccountId)\n    return crossAccountId.Substrate ? {substrate: crossAccountId.Substrate} : {ethereum: crossAccountId.Ethereum!}\n  },\n  crossAccountIdUncapitalizedSafe: (addressOrCrossAccountId: string | object): CrossAccountIdUncapitalized | null => {\n    try {\n      return extract.crossAccountIdUncapitalized(addressOrCrossAccountId)\n    } catch {\n      return null\n    }\n  },\n  crossAccountIdUncapitalizedNormalized: (addressOrCrossAccountId: string | object): CrossAccountIdUncapitalized => {\n    const crossAccountId = guessAddressAndExtractCrossAccountIdUnsafe(addressOrCrossAccountId, true)\n    return crossAccountId.Substrate ? {substrate: crossAccountId.Substrate} : {ethereum: crossAccountId.Ethereum!}\n  },\n  crossAccountIdUncapitalizedNormalizedSafe: (addressOrCrossAccountId: string | object): CrossAccountIdUncapitalized | null => {\n    try {\n      return extract.crossAccountIdUncapitalizedNormalized(addressOrCrossAccountId)\n    } catch {\n      return null\n    }\n  },\n\n\n  substrateOrMirrorIfEthereum: (addressOrCrossAccountId: string | object): string => {\n    return substrateOrMirrorIfEthereum(addressOrCrossAccountId)\n  },\n  substrateOrMirrorIfEthereumSafe: (addressOrCrossAccountId: string | object): string | null => {\n    try {\n      return substrateOrMirrorIfEthereum(addressOrCrossAccountId)\n    } catch {\n      return null\n    }\n  },\n\n  substrateOrMirrorIfEthereumNormalized: (addressOrCrossAccountId: string | object): string => {\n    return substrateOrMirrorIfEthereum(addressOrCrossAccountId, true)\n  },\n  substrateOrMirrorIfEthereumNormalizedSafe: (addressOrCrossAccountId: string | object): string | null => {\n    try {\n      return substrateOrMirrorIfEthereum(addressOrCrossAccountId, true)\n    } catch {\n      return null\n    }\n  },\n\n  substratePublicKey: (addressOrCrossAccountId: string | object): string => {\n    const crossAccountId = guessAddressAndExtractCrossAccountIdUnsafe(addressOrCrossAccountId)\n    if (!crossAccountId.Substrate) {\n      throw new Error('Address is not a substrate address')\n    }\n    return substrate.decode(crossAccountId.Substrate).hex\n  },\n  substratePublicKeySafe: (addressOrCrossAccountId: string | object): string | null => {\n    try {\n      return extract.substratePublicKey(addressOrCrossAccountId)\n    } catch {\n      return null\n    }\n  },\n\n  enhancedCrossAccountId: (addressInAnyForm: string | object, ss58Prefix: number = 42): EnhancedCrossAccountId => {\n    return addressInAnyFormToEnhancedCrossAccountId(addressInAnyForm, ss58Prefix)\n  },\n  enhancedCrossAccountIdSafe: (addressInAnyForm: string | object, ss58Prefix: number = 42): EnhancedCrossAccountId | null => {\n    try {\n      return addressInAnyFormToEnhancedCrossAccountId(addressInAnyForm, ss58Prefix)\n    } catch {\n      return null\n    }\n  },\n\n  ethCrossAccountId: (addressInAnyForm: string | object): EthCrossAccountId => {\n    const addressEnhanced = addressInAnyFormToEnhancedCrossAccountId(addressInAnyForm)\n    if (addressEnhanced.Substrate) {\n      return {\n        eth: '0x0000000000000000000000000000000000000000',\n        sub: addressEnhanced.substratePublicKey,\n      }\n    } else {\n      return {\n        eth: addressEnhanced.address,\n        sub: '0x00',\n      }\n    }\n  },\n  ethCrossAccountIdSafe: (addressInAnyForm: string | object): EthCrossAccountId | null => {\n    try {\n      return extract.ethCrossAccountId(addressInAnyForm)\n    } catch {\n      return null\n    }\n  }\n}\n\nexport const mirror = {\n  substrateToEthereum: addressToEvm,\n  ethereumToSubstrate: evmToAddress,\n}\n\nexport const normalize = {\n  substrateAddress: normalizeSubstrateAddress,\n  ethereumAddress: normalizeEthereumAddress,\n}\n\nexport const compare = {\n  substrateAddresses: compareSubstrateAddresses,\n  ethereumAddresses: compareEthereumAddresses,\n}\n\nexport const substrate = {\n  encode: encodeSubstrateAddress,\n  decode: decodeSubstrateAddress,\n  compare: compareSubstrateAddresses,\n}\n\nexport const Address = {\n  constants,\n  algorithms,\n  is,\n  validate,\n  collection,\n  nesting,\n  extract,\n  mirror,\n  normalize,\n  compare,\n  substrate,\n  utils: {\n    DWORDHexString,\n  }\n}\n","export const STATIC_ADDRESSES = <const>{\r\n  contractHelpers: '0x842899ECF380553E8a4de75bF534cdf6fBF64049',\r\n  collectionHelpers: '0x6C4E9fE1AE37a41E93CEE429e8E1881aBdcbb54F',\r\n}\r\nexport const NESTING_PREFIX = <const>'0xf8238ccfff8ed887463fd5e0'\r\nexport const COLLECTION_ADDRESS_PREFIX = <const>'0x17c4e6453cc49aaaaeaca894e6d9683e'\r\n","import basex from 'base-x'\r\nimport {keccak_256} from '@noble/hashes/sha3'\r\nimport {blake2b} from '@noble/hashes/blake2b'\r\n\r\nconst BASE58_ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\r\nconst BASE64_ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\r\n\r\nconst base58 = basex(BASE58_ALPHABET)\r\nconst base64 = basex(BASE64_ALPHABET)\r\n\r\nexport {keccak_256, blake2b, base58, base64, basex}\r\n","import {HexString} from 'utf-helpers'\n\nimport {keccak_256} from \"./imports\"\nimport {COLLECTION_ADDRESS_PREFIX, NESTING_PREFIX} from \"./constants\"\nimport {is, validate} from \"./index\"\n\n\nexport const DWORDHexString = {\n  _checkU32: (num: number): number => {\n    if (typeof num !== 'number') throw new Error(`Passed number is not a number: ${typeof num}, ${num}`)\n    if (isNaN(num)) throw new Error(`Passed number is NaN: ${num}`)\n    if (num < 0) throw new Error(`Passed number is less than 0: ${num}`)\n    if (num > 0xFFFFFFFF) throw new Error(`Passed number is more than 2**32: ${num}`)\n    if (num !== Math.floor(num)) throw new Error(`Passed number is not an integer number: ${num}`)\n\n    return num\n  },\n  fromNumber: (n: number): string => {\n    return DWORDHexString._checkU32(n).toString(16).padStart(8, '0')\n  },\n  toNumber: (s: string): number => {\n    const num: number = parseInt(s, 16)\n\n    if (isNaN(num)) throw new Error(`Passed string is not hexadecimal: ${s}`)\n\n    return DWORDHexString._checkU32(num)\n  }\n}\n\n\nconst unsafeNormalizeEthereumAddress = (address: string) => {\n  const addr = address.toLowerCase().replace(/^0x/i, '')\n  const addressHash = HexString.fromU8a(keccak_256(addr)).replace(/^0x/i, '')\n\n  let checksumAddress = '0x'\n\n  for (let i = 0; i < addr.length; i++) {\n    checksumAddress += (parseInt(addressHash[i], 16) > 7)\n      ? addr[i].toUpperCase()\n      : addr[i]\n  }\n\n  return checksumAddress\n}\nexport const normalizeEthereumAddress = (address: string) => {\n  validate.ethereumAddress(address)\n  return unsafeNormalizeEthereumAddress(address)\n}\n\ntype EthAddressObj = { Ethereum: string }\nexport const compareEthereumAddresses = (address1: string | object, address2: string | object): boolean => {\n  const addr1 = typeof address1 === 'string'\n    ? address1\n    : ((address1 as EthAddressObj).Ethereum || (address1 as any).ethereum) as string | undefined\n  const addr2 = typeof address2 === 'string'\n    ? address2\n    : ((address2 as EthAddressObj).Ethereum || (address2 as any).ethereum) as string | undefined\n\n  if (!addr1 || !addr2 || !is.ethereumAddress(addr1) || !is.ethereumAddress(addr2)) {\n    return false\n  }\n  return addr1.toLowerCase() === addr2.toLowerCase()\n\n}\n\nexport const collectionIdToEthAddress = (collectionId: number): string => {\n  validate.collectionId(collectionId)\n  return unsafeNormalizeEthereumAddress(\n    COLLECTION_ADDRESS_PREFIX +\n    DWORDHexString.fromNumber(collectionId)\n  )\n}\nexport const ethAddressToCollectionId = (address: string): number => {\n  validate.collectionAddress(address)\n  return DWORDHexString.toNumber(address.slice(-8))\n}\n\nexport const collectionIdAndTokenIdToNestingAddress = (collectionId: number, tokenId: number): string => {\n  validate.collectionId(collectionId)\n  validate.tokenId(tokenId)\n\n  return unsafeNormalizeEthereumAddress(\n    NESTING_PREFIX +\n    DWORDHexString.fromNumber(collectionId) +\n    DWORDHexString.fromNumber(tokenId)\n  )\n}\n\nexport const nestingAddressToCollectionIdAndTokenId = (address: string): { collectionId: number, tokenId: number } => {\n  validate.nestingAddress(address)\n  return {\n    collectionId: DWORDHexString.toNumber(address.slice(-16, -8)),\n    tokenId: DWORDHexString.toNumber(address.slice(-8)),\n  }\n}\n","import {base58, blake2b} from './imports'\nimport {DecodeSubstrateAddressResult, validate, is} from './index'\nimport {normalizeEthereumAddress} from './ethereum'\nimport {HexString} from 'utf-helpers'\n\nconst blake2AsU8a = (u8a: Uint8Array, dkLen: 8 | 16 | 32 | 48 | 64 = 32): Uint8Array => {\n  return blake2b(u8a, {dkLen})\n}\n\nconst u8aConcat = (u8as: readonly Uint8Array[]): Uint8Array => {\n  let offset = 0\n\n  let length = 0\n\n  for (let i = 0; i < u8as.length; i++) {\n    length += u8as[i].length\n  }\n\n  const result = new Uint8Array(length)\n\n  for (let i = 0; i < u8as.length; i++) {\n    result.set(u8as[i], offset)\n    offset += u8as[i].length\n  }\n\n  return result\n}\n\n// strToU8a('SS58PRE')\nconst SS58_PREFIX = new Uint8Array([83, 83, 53, 56, 80, 82, 69])\n\nconst sshash = (data: Uint8Array): Uint8Array => {\n  return blake2AsU8a(u8aConcat([SS58_PREFIX, data]), 64);\n}\n\nconst checkAddressChecksum = (decoded: Uint8Array, ignoreChecksum: boolean = false): [boolean, number, number, number] => {\n  const ss58Length = (decoded[0] & 0b0100_0000) ? 2 : 1;\n  const ss58Decoded = ss58Length === 1\n    ? decoded[0]\n    : ((decoded[0] & 0x3f) << 2) | (decoded[1] >> 6) | ((decoded[1] & 0x3f) << 8);\n\n  // 32/33 bytes public + 2 bytes checksum + prefix\n  const isPublicKey = [34 + ss58Length, 35 + ss58Length].includes(decoded.length);\n  const length = decoded.length - (isPublicKey ? 2 : 1);\n\n  let isValid = false\n\n  if (!ignoreChecksum) {\n    // calculate the hash and do the checksum byte checks\n    const hash = sshash(decoded.subarray(0, length));\n    isValid = (decoded[0] & 0x80) === 0 && ![46, 47].includes(decoded[0]) && (\n      isPublicKey\n        ? decoded[decoded.length - 2] === hash[0] && decoded[decoded.length - 1] === hash[1]\n        : decoded[decoded.length - 1] === hash[0]\n    )\n  }\n\n  return [isValid, length, ss58Length, ss58Decoded];\n}\n\nexport const normalizeSubstrateAddress = (address: string, prefix: number = 42): string => {\n  return encodeSubstrateAddress(decodeSubstrateAddress(address).u8a, prefix)\n}\n\n\nexport function encodeSubstrateAddress(key: Uint8Array | string | bigint, ss58Format: number = 42): string {\n  const u8a: Uint8Array = typeof key === 'string'\n    ? HexString.toU8a(key)\n    : typeof key === 'bigint'\n      ? HexString.toU8a(key.toString(16))\n      : key\n\n  if (ss58Format < 0 || ss58Format > 16383 || [46, 47].includes(ss58Format)) {\n    throw new Error(`ss58Format is not valid, received ${typeof ss58Format} \"${ss58Format}\"`)\n  }\n\n  const allowedDecodedLengths = [1, 2, 4, 8, 32, 33]\n  if (!allowedDecodedLengths.includes(u8a.length)) {\n    throw new Error(`key length is not valid, received ${u8a.length}, valid values are ${allowedDecodedLengths.join(', ')}`)\n  }\n\n  const u8aPrefix = ss58Format < 64\n    ? new Uint8Array([ss58Format])\n    : new Uint8Array([\n      ((ss58Format & 0xfc) >> 2) | 0x40,\n      (ss58Format >> 8) | ((ss58Format & 0x03) << 6)\n    ])\n\n  const input = u8aConcat([u8aPrefix, u8a])\n\n  return base58.encode(\n    u8aConcat([\n      input,\n      sshash(input).subarray(0, [32, 33].includes(u8a.length) ? 2 : 1)\n    ])\n  );\n}\n\nexport function decodeSubstrateAddress(address: string, ignoreChecksum?: boolean, ss58Format: number = -1): DecodeSubstrateAddressResult {\n  let realError: Error | null = null\n\n  try {\n    if (is.substratePublicKey(address)) {\n      return {\n        u8a: HexString.toU8a(address),\n        bigint: BigInt(address),\n        hex: address,\n        ss58Prefix: 42,\n      }\n    } else if (address.startsWith('0x')) {\n      throw new Error(`Invalid substrate address, received ${address}. Wrong or mangled public key?`)\n    }\n\n    const decoded = base58.decode(address);\n\n    const allowedEncodedLengths = [3, 4, 6, 10, 35, 36, 37, 38]\n\n    if (!allowedEncodedLengths.includes(decoded.length)) {\n      realError = new Error(`key length is not valid, decoded key length is ${decoded.length}, valid values are ${allowedEncodedLengths.join(', ')}`)\n      throw realError\n    }\n\n    const [isValid, endPos, ss58Length, ss58Decoded] = checkAddressChecksum(decoded, ignoreChecksum)\n\n    if (!ignoreChecksum && !isValid) {\n      realError = new Error(`Invalid decoded address checksum`)\n      throw realError\n    }\n    if (![-1, ss58Decoded].includes(ss58Format)) {\n      realError = new Error(`Expected ss58Format ${ss58Format}, received ${ss58Decoded}`)\n      throw realError\n    }\n\n    const publicKey = decoded.slice(ss58Length, endPos)\n\n    const hex: string = HexString.fromU8a(publicKey)\n    return {\n      u8a: publicKey,\n      hex,\n      bigint: BigInt(hex),\n      ss58Prefix: ss58Decoded,\n    }\n  } catch (error) {\n    throw realError\n      ? realError\n      : new Error(`Decoding ${address}: ${(error as Error).message}`)\n  }\n}\n\ntype SubAddressObj = { Substrate: string }\nexport const compareSubstrateAddresses = (address1: string | object, address2: string | object): boolean => {\n  const addr1 = typeof address1 === 'string'\n    ? address1\n    : ((address1 as SubAddressObj).Substrate || (address1 as any).substrate) as string | undefined\n  const addr2 = typeof address2 === 'string'\n    ? address2\n    : ((address2 as SubAddressObj).Substrate || (address2 as any).substrate) as string | undefined\n\n  if (!addr1 || !addr2) {\n    return false\n  }\n\n  try {\n    const decoded1 = decodeSubstrateAddress(addr1)\n    const decoded2 = decodeSubstrateAddress(addr2)\n    return decoded1.bigint === decoded2.bigint\n  } catch (e) {\n    return false\n  }\n}\n\nexport const addressToEvm = (address: string, ignoreChecksum?: boolean): string => {\n  const truncated = decodeSubstrateAddress(address, ignoreChecksum).u8a.subarray(0, 20)\n  return normalizeEthereumAddress(HexString.fromU8a(truncated))\n}\n\n// strToU8a('evm:')\nconst EVM_PREFIX_U8A = new Uint8Array([101, 118, 109, 58])\nexport const evmToAddress = (evmAddress: string, ss58Format: number = 42): string => {\n  validate.ethereumAddress(evmAddress)\n\n  const message = u8aConcat([EVM_PREFIX_U8A, HexString.toU8a(evmAddress)])\n\n  return encodeSubstrateAddress(blake2AsU8a(message), ss58Format)\n}\n","import {normalizeEthereumAddress} from './ethereum'\nimport {normalizeSubstrateAddress, decodeSubstrateAddress} from './substrate'\nimport {CrossAccountId, EnhancedCrossAccountId} from '../types'\nimport {is, mirror, validate} from './index'\n\nexport const guessAddressAndExtractCrossAccountIdUnsafe = (rawAddress: string | object, normalize: boolean = false): CrossAccountId => {\n  const address = rawAddress as any\n\n  if (typeof address === 'object') {\n    if (address.hasOwnProperty('eth') && address.hasOwnProperty('sub')) {\n      // bn.js value extraction for ethers.js\n      const subPublicKey = (address.sub.hasOwnProperty('_hex') && typeof address.sub._hex === 'string')\n        ? address.sub._hex\n        : address.sub\n      if (typeof subPublicKey !== 'string' || !subPublicKey.startsWith('0x')) {\n        throw new Error(`Substrate public key must be a hex string, got ${subPublicKey}`)\n      }\n\n      const subBigInt = BigInt(subPublicKey)\n      const ethBigInt = BigInt(address.eth)\n\n      if (!(Number(subBigInt === 0n) ^ Number(ethBigInt === 0n))) {\n        throw new Error(`One of the addresses must be 0, got eth ${address.eth} and substrate public key ${address.sub}.`)\n      }\n\n      // always normalize addresses from the EthCrossAccountId\n      if (subBigInt === 0n) {\n        return {Ethereum: normalizeEthereumAddress(address.eth)}\n      } else {\n        return {Substrate: normalizeSubstrateAddress(subPublicKey)}\n      }\n    } else if (address.hasOwnProperty('Substrate') || address.hasOwnProperty('substrate')) {\n      const substrateAddress = address.hasOwnProperty('Substrate') ? address.Substrate : address.substrate\n      if (is.substratePublicKey(substrateAddress)) {\n        return {Substrate: normalizeSubstrateAddress(substrateAddress)}\n      } else if (is.substrateAddress(substrateAddress)) {\n        return {Substrate: normalize ? normalizeSubstrateAddress(substrateAddress) : substrateAddress}\n      } else {\n        throw new Error(`Address ${substrateAddress} is not a valid Substrate address`)\n      }\n    } else if (address.hasOwnProperty('Ethereum') || address.hasOwnProperty('ethereum')) {\n      const ethereumAddress = address.hasOwnProperty('Ethereum') ? address.Ethereum : address.ethereum\n      validate.ethereumAddress(ethereumAddress)\n      return {Ethereum: normalize ? normalizeEthereumAddress(ethereumAddress) : ethereumAddress}\n    } else {\n      throw new Error(`Address ${address} is not a valid crossAccountId object (should contain \"Substrate\"/\"substrate\" or \"Ethereum\"/\"ethereum\" field) or EthCrossAccountId (should contain \"eth\" and \"sub\" fields)`)\n    }\n  }\n\n  if (typeof address === 'string') {\n    if (is.substrateAddress(address)) return {Substrate: normalize ? normalizeSubstrateAddress(address) : address}\n    else if (is.ethereumAddress(address)) return {Ethereum: normalize ? normalizeEthereumAddress(address) : address}\n    else if (is.substratePublicKey(address)) return {Substrate: normalizeSubstrateAddress(address)}\n    else {\n      throw new Error(`Address ${address} is not a valid Substrate or Ethereum address`)\n    }\n  }\n\n  throw new Error(`Address ${address} is not a string or object: ${typeof address}`)\n}\n\nexport const guessAddressAndExtractCrossAccountIdSafe = (address: string | object, normalize: boolean = false): CrossAccountId | null => {\n  try {\n    return guessAddressAndExtractCrossAccountIdUnsafe(address, normalize)\n  } catch {\n    return null\n  }\n}\n\nexport const substrateOrMirrorIfEthereum = (address: string | object, normalize: boolean = false): string => {\n  const addressObject = guessAddressAndExtractCrossAccountIdUnsafe(address, normalize)\n  return addressObject.Substrate\n    ? addressObject.Substrate\n    : mirror.ethereumToSubstrate(addressObject.Ethereum as string)\n}\n\nexport const addressInAnyFormToEnhancedCrossAccountId = (address: string | object, ss58Prefix: number = 42): EnhancedCrossAccountId => {\n  const crossAccountId = guessAddressAndExtractCrossAccountIdUnsafe(address)\n\n  if (crossAccountId.Ethereum) {\n    const normalized = normalizeEthereumAddress(crossAccountId.Ethereum)\n    return {\n      ...crossAccountId,\n      address: normalized,\n      addressSS58: normalized,\n      substratePublicKey: normalized,\n      isEthereum: true,\n      isSubstrate: false,\n      type: 'Ethereum',\n    }\n  } else {\n    return {\n      ...crossAccountId,\n      address: normalizeSubstrateAddress(crossAccountId.Substrate as string),\n      addressSS58: normalizeSubstrateAddress(crossAccountId.Substrate as string, ss58Prefix),\n      substratePublicKey: decodeSubstrateAddress(crossAccountId.Substrate as string).hex,\n      isEthereum: false,\n      isSubstrate: true,\n      type: 'Substrate',\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
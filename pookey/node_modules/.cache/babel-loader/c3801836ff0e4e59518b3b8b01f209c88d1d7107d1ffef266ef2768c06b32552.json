{"ast":null,"code":"import { combineLatest, map, of, switchMap } from 'rxjs';\nimport { firstMemo, memo } from '../util/index.js';\nfunction rewardDestinationCompat(rewardDestination) {\n  // We ensure the type is an Option by checking if isSome is a boolean. When isSome doesn't exist it will always return undefined.\n  return typeof rewardDestination.isSome === 'boolean' ? rewardDestination.unwrapOr(null) : rewardDestination;\n}\nfunction filterClaimedRewards(api, cl) {\n  return api.registry.createType('Vec<u32>', cl.filter(c => c !== -1));\n}\nfunction filterRewards(stashIds, eras, claimedRewards, stakersOverview) {\n  const claimedData = {};\n  const overviewData = {};\n  const ids = stashIds.map(i => i.toString());\n  claimedRewards.forEach(([keys, rewards]) => {\n    const id = keys.args[1].toString();\n    const era = keys.args[0].toNumber();\n    if (ids.includes(id)) {\n      if (claimedData[id]) {\n        claimedData[id].set(era, rewards.toArray());\n      } else {\n        claimedData[id] = new Map();\n        claimedData[id].set(era, rewards.toArray());\n      }\n    }\n  });\n  stakersOverview.forEach(([keys, overview]) => {\n    const id = keys.args[1].toString();\n    const era = keys.args[0].toNumber();\n    if (ids.includes(id) && overview.isSome) {\n      if (overviewData[id]) {\n        overviewData[id].set(era, overview.unwrap().pageCount);\n      } else {\n        overviewData[id] = new Map();\n        overviewData[id].set(era, overview.unwrap().pageCount);\n      }\n    }\n  });\n  return stashIds.map(id => {\n    const rewardsPerEra = claimedData[id.toString()];\n    const overviewPerEra = overviewData[id.toString()];\n    return eras.map(era => {\n      if (rewardsPerEra && rewardsPerEra.has(era) && overviewPerEra && overviewPerEra.has(era)) {\n        const rewards = rewardsPerEra.get(era);\n        const pageCount = overviewPerEra.get(era);\n        return rewards.length === pageCount.toNumber() ? era : -1;\n      }\n      return -1;\n    });\n  });\n}\nfunction parseDetails(api, stashId, controllerIdOpt, nominatorsOpt, rewardDestinationOpts, validatorPrefs, exposure, stakingLedgerOpt, exposureMeta, claimedRewards, exposureEraStakers) {\n  return {\n    accountId: stashId,\n    claimedRewardsEras: filterClaimedRewards(api, claimedRewards),\n    controllerId: controllerIdOpt?.unwrapOr(null) || null,\n    exposureEraStakers,\n    exposureMeta,\n    exposurePaged: exposure,\n    nominators: nominatorsOpt.isSome ? nominatorsOpt.unwrap().targets : [],\n    rewardDestination: rewardDestinationCompat(rewardDestinationOpts),\n    stakingLedger: stakingLedgerOpt.unwrapOrDefault(),\n    stashId,\n    validatorPrefs\n  };\n}\nfunction getLedgers(api, optIds, {\n  withLedger = false\n}) {\n  const ids = optIds.filter(o => withLedger && !!o && o.isSome).map(o => o.unwrap());\n  const emptyLed = api.registry.createType('Option<StakingLedger>');\n  return (ids.length ? combineLatest(ids.map(s => api.query.staking.ledger(s))) : of([])).pipe(map(optLedgers => {\n    let offset = -1;\n    return optIds.map(o => o && o.isSome ? optLedgers[++offset] || emptyLed : emptyLed);\n  }));\n}\nfunction getStashInfo(api, stashIds, activeEra, {\n  withClaimedRewardsEras,\n  withController,\n  withDestination,\n  withExposure,\n  withExposureErasStakersLegacy,\n  withExposureMeta,\n  withLedger,\n  withNominations,\n  withPrefs\n}, page) {\n  const emptyNoms = api.registry.createType('Option<Nominations>');\n  const emptyRewa = api.registry.createType('RewardDestination');\n  const emptyExpoEraStakers = api.registry.createType('Exposure');\n  const emptyPrefs = api.registry.createType('ValidatorPrefs');\n  // The reason we don't explicitly make the actual types is for compatibility. If the chain doesn't have the noted type it will fail\n  // on construction. Therefore we just make an empty option.\n  const emptyExpo = api.registry.createType('Option<Null>');\n  const emptyExpoMeta = api.registry.createType('Option<Null>');\n  const emptyClaimedRewards = [-1];\n  const depth = Number(api.consts.staking.historyDepth.toNumber());\n  const eras = new Array(depth).fill(0).map((_, idx) => {\n    if (idx === 0) {\n      return activeEra.toNumber() - 1;\n    }\n    return activeEra.toNumber() - idx - 1;\n  });\n  return combineLatest([withController || withLedger ? combineLatest(stashIds.map(s => api.query.staking.bonded(s))) : of(stashIds.map(() => null)), withNominations ? combineLatest(stashIds.map(s => api.query.staking.nominators(s))) : of(stashIds.map(() => emptyNoms)), withDestination ? combineLatest(stashIds.map(s => api.query.staking.payee(s))) : of(stashIds.map(() => emptyRewa)), withPrefs ? combineLatest(stashIds.map(s => api.query.staking.validators(s))) : of(stashIds.map(() => emptyPrefs)), withExposure && api.query.staking.erasStakersPaged ? combineLatest(stashIds.map(s => api.query.staking.erasStakersPaged(activeEra, s, page))) : of(stashIds.map(() => emptyExpo)), withExposureMeta && api.query.staking.erasStakersOverview ? combineLatest(stashIds.map(s => api.query.staking.erasStakersOverview(activeEra, s))) : of(stashIds.map(() => emptyExpoMeta)), withClaimedRewardsEras && api.query.staking.claimedRewards ? combineLatest([api.query.staking.claimedRewards.entries(), api.query.staking.erasStakersOverview.entries()]).pipe(map(([rewardsStorageVec, overviewStorageVec]) => filterRewards(stashIds, eras, rewardsStorageVec, overviewStorageVec))) : of(stashIds.map(() => emptyClaimedRewards)), withExposureErasStakersLegacy && api.query.staking.erasStakers ? combineLatest(stashIds.map(s => api.query.staking.erasStakers(activeEra, s))) : of(stashIds.map(() => emptyExpoEraStakers))]);\n}\nfunction getBatch(api, activeEra, stashIds, flags, page) {\n  return getStashInfo(api, stashIds, activeEra, flags, page).pipe(switchMap(([controllerIdOpt, nominatorsOpt, rewardDestination, validatorPrefs, exposure, exposureMeta, claimedRewardsEras, exposureEraStakers]) => getLedgers(api, controllerIdOpt, flags).pipe(map(stakingLedgerOpts => stashIds.map((stashId, index) => parseDetails(api, stashId, controllerIdOpt[index], nominatorsOpt[index], rewardDestination[index], validatorPrefs[index], exposure[index], stakingLedgerOpts[index], exposureMeta[index], claimedRewardsEras[index], exposureEraStakers[index]))))));\n}\n/**\n * @description From a stash, retrieve the controllerId and all relevant details\n */\nexport const query = /*#__PURE__*/firstMemo((api, accountId, flags, page) => api.derive.staking.queryMulti([accountId], flags, page));\nexport function queryMulti(instanceId, api) {\n  return memo(instanceId, (accountIds, flags, page) => api.derive.session.indexes().pipe(switchMap(({\n    activeEra\n  }) => {\n    const stashIds = accountIds.map(a => api.registry.createType('AccountId', a));\n    const p = page || 0;\n    return stashIds.length ? getBatch(api, activeEra, stashIds, flags, p) : of([]);\n  })));\n}","map":{"version":3,"names":["combineLatest","map","of","switchMap","firstMemo","memo","rewardDestinationCompat","rewardDestination","isSome","unwrapOr","filterClaimedRewards","api","cl","registry","createType","filter","c","filterRewards","stashIds","eras","claimedRewards","stakersOverview","claimedData","overviewData","ids","i","toString","forEach","keys","rewards","id","args","era","toNumber","includes","set","toArray","Map","overview","unwrap","pageCount","rewardsPerEra","overviewPerEra","has","get","length","parseDetails","stashId","controllerIdOpt","nominatorsOpt","rewardDestinationOpts","validatorPrefs","exposure","stakingLedgerOpt","exposureMeta","exposureEraStakers","accountId","claimedRewardsEras","controllerId","exposurePaged","nominators","targets","stakingLedger","unwrapOrDefault","getLedgers","optIds","withLedger","o","emptyLed","s","query","staking","ledger","pipe","optLedgers","offset","getStashInfo","activeEra","withClaimedRewardsEras","withController","withDestination","withExposure","withExposureErasStakersLegacy","withExposureMeta","withNominations","withPrefs","page","emptyNoms","emptyRewa","emptyExpoEraStakers","emptyPrefs","emptyExpo","emptyExpoMeta","emptyClaimedRewards","depth","Number","consts","historyDepth","Array","fill","_","idx","bonded","payee","validators","erasStakersPaged","erasStakersOverview","entries","rewardsStorageVec","overviewStorageVec","erasStakers","getBatch","flags","stakingLedgerOpts","index","derive","queryMulti","instanceId","accountIds","session","indexes","a","p"],"sources":["C:/Users/khyy4/Documents/Code-Projects/polkahack/pookey/node_modules/@polkadot/api-derive/staking/query.js"],"sourcesContent":["import { combineLatest, map, of, switchMap } from 'rxjs';\nimport { firstMemo, memo } from '../util/index.js';\nfunction rewardDestinationCompat(rewardDestination) {\n    // We ensure the type is an Option by checking if isSome is a boolean. When isSome doesn't exist it will always return undefined.\n    return typeof rewardDestination.isSome === 'boolean'\n        ? rewardDestination.unwrapOr(null)\n        : rewardDestination;\n}\nfunction filterClaimedRewards(api, cl) {\n    return api.registry.createType('Vec<u32>', cl.filter((c) => c !== -1));\n}\nfunction filterRewards(stashIds, eras, claimedRewards, stakersOverview) {\n    const claimedData = {};\n    const overviewData = {};\n    const ids = stashIds.map((i) => i.toString());\n    claimedRewards.forEach(([keys, rewards]) => {\n        const id = keys.args[1].toString();\n        const era = keys.args[0].toNumber();\n        if (ids.includes(id)) {\n            if (claimedData[id]) {\n                claimedData[id].set(era, rewards.toArray());\n            }\n            else {\n                claimedData[id] = new Map();\n                claimedData[id].set(era, rewards.toArray());\n            }\n        }\n    });\n    stakersOverview.forEach(([keys, overview]) => {\n        const id = keys.args[1].toString();\n        const era = keys.args[0].toNumber();\n        if (ids.includes(id) && overview.isSome) {\n            if (overviewData[id]) {\n                overviewData[id].set(era, overview.unwrap().pageCount);\n            }\n            else {\n                overviewData[id] = new Map();\n                overviewData[id].set(era, overview.unwrap().pageCount);\n            }\n        }\n    });\n    return stashIds.map((id) => {\n        const rewardsPerEra = claimedData[id.toString()];\n        const overviewPerEra = overviewData[id.toString()];\n        return eras.map((era) => {\n            if (rewardsPerEra && rewardsPerEra.has(era) && overviewPerEra && overviewPerEra.has(era)) {\n                const rewards = rewardsPerEra.get(era);\n                const pageCount = overviewPerEra.get(era);\n                return rewards.length === pageCount.toNumber()\n                    ? era\n                    : -1;\n            }\n            return -1;\n        });\n    });\n}\nfunction parseDetails(api, stashId, controllerIdOpt, nominatorsOpt, rewardDestinationOpts, validatorPrefs, exposure, stakingLedgerOpt, exposureMeta, claimedRewards, exposureEraStakers) {\n    return {\n        accountId: stashId,\n        claimedRewardsEras: filterClaimedRewards(api, claimedRewards),\n        controllerId: controllerIdOpt?.unwrapOr(null) || null,\n        exposureEraStakers,\n        exposureMeta,\n        exposurePaged: exposure,\n        nominators: nominatorsOpt.isSome\n            ? nominatorsOpt.unwrap().targets\n            : [],\n        rewardDestination: rewardDestinationCompat(rewardDestinationOpts),\n        stakingLedger: stakingLedgerOpt.unwrapOrDefault(),\n        stashId,\n        validatorPrefs\n    };\n}\nfunction getLedgers(api, optIds, { withLedger = false }) {\n    const ids = optIds\n        .filter((o) => withLedger && !!o && o.isSome)\n        .map((o) => o.unwrap());\n    const emptyLed = api.registry.createType('Option<StakingLedger>');\n    return (ids.length\n        ? combineLatest(ids.map((s) => api.query.staking.ledger(s)))\n        : of([])).pipe(map((optLedgers) => {\n        let offset = -1;\n        return optIds.map((o) => o && o.isSome\n            ? optLedgers[++offset] || emptyLed\n            : emptyLed);\n    }));\n}\nfunction getStashInfo(api, stashIds, activeEra, { withClaimedRewardsEras, withController, withDestination, withExposure, withExposureErasStakersLegacy, withExposureMeta, withLedger, withNominations, withPrefs }, page) {\n    const emptyNoms = api.registry.createType('Option<Nominations>');\n    const emptyRewa = api.registry.createType('RewardDestination');\n    const emptyExpoEraStakers = api.registry.createType('Exposure');\n    const emptyPrefs = api.registry.createType('ValidatorPrefs');\n    // The reason we don't explicitly make the actual types is for compatibility. If the chain doesn't have the noted type it will fail\n    // on construction. Therefore we just make an empty option.\n    const emptyExpo = api.registry.createType('Option<Null>');\n    const emptyExpoMeta = api.registry.createType('Option<Null>');\n    const emptyClaimedRewards = [-1];\n    const depth = Number(api.consts.staking.historyDepth.toNumber());\n    const eras = new Array(depth).fill(0).map((_, idx) => {\n        if (idx === 0) {\n            return activeEra.toNumber() - 1;\n        }\n        return activeEra.toNumber() - idx - 1;\n    });\n    return combineLatest([\n        withController || withLedger\n            ? combineLatest(stashIds.map((s) => api.query.staking.bonded(s)))\n            : of(stashIds.map(() => null)),\n        withNominations\n            ? combineLatest(stashIds.map((s) => api.query.staking.nominators(s)))\n            : of(stashIds.map(() => emptyNoms)),\n        withDestination\n            ? combineLatest(stashIds.map((s) => api.query.staking.payee(s)))\n            : of(stashIds.map(() => emptyRewa)),\n        withPrefs\n            ? combineLatest(stashIds.map((s) => api.query.staking.validators(s)))\n            : of(stashIds.map(() => emptyPrefs)),\n        withExposure && api.query.staking.erasStakersPaged\n            ? combineLatest(stashIds.map((s) => api.query.staking.erasStakersPaged(activeEra, s, page)))\n            : of(stashIds.map(() => emptyExpo)),\n        withExposureMeta && api.query.staking.erasStakersOverview\n            ? combineLatest(stashIds.map((s) => api.query.staking.erasStakersOverview(activeEra, s)))\n            : of(stashIds.map(() => emptyExpoMeta)),\n        withClaimedRewardsEras && api.query.staking.claimedRewards\n            ? combineLatest([\n                api.query.staking.claimedRewards.entries(),\n                api.query.staking.erasStakersOverview.entries()\n            ]).pipe(map(([rewardsStorageVec, overviewStorageVec]) => filterRewards(stashIds, eras, rewardsStorageVec, overviewStorageVec)))\n            : of(stashIds.map(() => emptyClaimedRewards)),\n        withExposureErasStakersLegacy && api.query.staking.erasStakers\n            ? combineLatest(stashIds.map((s) => api.query.staking.erasStakers(activeEra, s)))\n            : of(stashIds.map(() => emptyExpoEraStakers))\n    ]);\n}\nfunction getBatch(api, activeEra, stashIds, flags, page) {\n    return getStashInfo(api, stashIds, activeEra, flags, page).pipe(switchMap(([controllerIdOpt, nominatorsOpt, rewardDestination, validatorPrefs, exposure, exposureMeta, claimedRewardsEras, exposureEraStakers]) => getLedgers(api, controllerIdOpt, flags).pipe(map((stakingLedgerOpts) => stashIds.map((stashId, index) => parseDetails(api, stashId, controllerIdOpt[index], nominatorsOpt[index], rewardDestination[index], validatorPrefs[index], exposure[index], stakingLedgerOpts[index], exposureMeta[index], claimedRewardsEras[index], exposureEraStakers[index]))))));\n}\n/**\n * @description From a stash, retrieve the controllerId and all relevant details\n */\nexport const query = /*#__PURE__*/ firstMemo((api, accountId, flags, page) => api.derive.staking.queryMulti([accountId], flags, page));\nexport function queryMulti(instanceId, api) {\n    return memo(instanceId, (accountIds, flags, page) => api.derive.session.indexes().pipe(switchMap(({ activeEra }) => {\n        const stashIds = accountIds.map((a) => api.registry.createType('AccountId', a));\n        const p = page || 0;\n        return stashIds.length\n            ? getBatch(api, activeEra, stashIds, flags, p)\n            : of([]);\n    })));\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
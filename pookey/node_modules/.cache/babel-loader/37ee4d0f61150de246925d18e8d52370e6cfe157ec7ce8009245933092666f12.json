{"ast":null,"code":"\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n      get: () => from[key],\n      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n    });\n  }\n  return to;\n};\nvar __toCommonJS = mod => __copyProps(__defProp({}, \"__esModule\", {\n  value: true\n}), mod);\n\n// index.ts\nvar utf_helpers_exports = {};\n__export(utf_helpers_exports, {\n  HexString: () => HexString,\n  Utf16: () => Utf16,\n  Utf8: () => Utf8,\n  UtfHelpers: () => UtfHelpers\n});\nmodule.exports = __toCommonJS(utf_helpers_exports);\nvar HexString = {\n  fromArray: bytes => {\n    if (!(bytes instanceof Uint8Array) && !Array.isArray(bytes)) {\n      throw new Error(`HexString.fromArray: passed bytes obj is not an Array or Uint8Array: ${typeof bytes}, ${bytes}`);\n    }\n    const arr = bytes instanceof Uint8Array ? Array.from(bytes) : bytes;\n    return \"0x\" + arr.reduce((str, byte) => str + byte.toString(16).padStart(2, \"0\"), \"\");\n  },\n  fromU8a: bytes => HexString.fromArray(bytes),\n  toArray(hexString) {\n    if (typeof hexString !== \"string\") {\n      throw new Error(`HexString.toArray: passed string is not a string: ${typeof hexString}`);\n    }\n    const str = hexString.startsWith(\"0x\") ? hexString.slice(2) : hexString;\n    const pairs = str.match(/.{1,2}/g) || [];\n    return pairs.map(byte => parseInt(byte, 16));\n  },\n  toU8a: hexString => Uint8Array.from(HexString.toArray(hexString))\n};\nvar Utf8 = {\n  stringToU8a(str) {\n    const u8a = new Uint8Array(Utf8.lengthInBytes(str));\n    let offset = 0;\n    const start = offset;\n    let c1 = 0;\n    let c2 = 0;\n    let i = 0;\n    while (i < str.length) {\n      c1 = str.charCodeAt(i);\n      if (c1 < 128) {\n        u8a[offset++] = c1;\n      } else if (c1 < 2048) {\n        u8a[offset++] = c1 >> 6 | 192;\n        u8a[offset++] = c1 & 63 | 128;\n      } else if ((c1 & 64512) === 55296 && ((c2 = str.charCodeAt(i + 1)) & 64512) === 56320) {\n        c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);\n        ++i;\n        u8a[offset++] = c1 >> 18 | 240;\n        u8a[offset++] = c1 >> 12 & 63 | 128;\n        u8a[offset++] = c1 >> 6 & 63 | 128;\n        u8a[offset++] = c1 & 63 | 128;\n      } else {\n        u8a[offset++] = c1 >> 12 | 224;\n        u8a[offset++] = c1 >> 6 & 63 | 128;\n        u8a[offset++] = c1 & 63 | 128;\n      }\n      i += 1;\n    }\n    const diff = offset - start;\n    return u8a;\n  },\n  stringToNumberArray(str) {\n    return Array.from(Utf8.stringToU8a(str));\n  },\n  u8aToString(u8a) {\n    let start = 0;\n    let end = u8a.length;\n    if (end - start < 1) {\n      return \"\";\n    }\n    let str = \"\";\n    let i = start;\n    while (i < end) {\n      const t = u8a[i++];\n      if (t <= 127) {\n        str += String.fromCharCode(t);\n      } else if (t >= 192 && t < 224) {\n        str += String.fromCharCode((t & 31) << 6 | u8a[i++] & 63);\n      } else if (t >= 224 && t < 240) {\n        str += String.fromCharCode((t & 15) << 12 | (u8a[i++] & 63) << 6 | u8a[i++] & 63);\n      } else if (t >= 240) {\n        const t2 = ((t & 7) << 18 | (u8a[i++] & 63) << 12 | (u8a[i++] & 63) << 6 | u8a[i++] & 63) - 65536;\n        str += String.fromCharCode(55296 + (t2 >> 10));\n        str += String.fromCharCode(56320 + (t2 & 1023));\n      }\n    }\n    return str;\n  },\n  numberArrayToString(arr) {\n    return Utf8.u8aToString(Uint8Array.from(arr));\n  },\n  stringToHexString(str) {\n    return HexString.fromU8a(Utf8.stringToU8a(str));\n  },\n  hexStringToString(hexString) {\n    return Utf8.u8aToString(HexString.toU8a(hexString));\n  },\n  lengthInBytes(str) {\n    let len = 0;\n    let c = 0;\n    let i = 0;\n    while (i < str.length) {\n      c = str.charCodeAt(i);\n      if (c < 128) {\n        len += 1;\n      } else if (c < 2048) {\n        len += 2;\n      } else if ((c & 64512) === 55296 && (str.charCodeAt(i + 1) & 64512) === 56320) {\n        ++i;\n        len += 4;\n      } else {\n        len += 3;\n      }\n      i += 1;\n    }\n    return len;\n  }\n};\nvar Utf16 = {\n  stringToU16a(str) {\n    const u16arr = new Uint16Array(Utf16.lengthInBytes(str));\n    let i = 0;\n    while (i < str.length) {\n      let cp = str.codePointAt(i);\n      if (cp <= 65535) {\n        u16arr[i++] = cp;\n      } else {\n        cp -= 65536;\n        u16arr[i++] = (cp >> 10) + 55296;\n        u16arr[i++] = cp % 1024 + 56320;\n      }\n    }\n    return u16arr;\n  },\n  stringToNumberArray(str) {\n    return Array.from(Utf16.stringToU16a(str));\n  },\n  numberArrayToString(arr) {\n    let i = 0;\n    const len = arr.length;\n    let s = \"\";\n    while (i < len - 1) {\n      const c1 = arr[i];\n      const c2 = arr[i + 1];\n      if (c1 >= 55296 && c1 <= 57343) {\n        if (c2 >= 56320 && c2 <= 57343) {\n          s += String.fromCodePoint((c1 - 55296) * 1024 + c2 - 56320 + 65536);\n          i += 2;\n        } else {\n          throw new Error(`invalid UTF16 sequence: first u16 is ${c1}, second u16 is ${c2}`);\n        }\n      } else {\n        s += String.fromCodePoint(c1);\n        i += 1;\n      }\n    }\n    if (i < len) {\n      s += String.fromCodePoint(arr[len - 1]);\n    }\n    return s;\n  },\n  u16aToString(arr) {\n    return Utf16.numberArrayToString(arr);\n  },\n  lengthInBytes(str) {\n    let i = 0;\n    while (i < str.length) {\n      i += str.codePointAt(i) <= 65535 ? 1 : 2;\n    }\n    return i;\n  }\n};\nvar UtfHelpers = {\n  HexString,\n  Utf8,\n  Utf16\n};\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {\n  HexString,\n  Utf16,\n  Utf8,\n  UtfHelpers\n});","map":{"version":3,"names":["utf_helpers_exports","__export","HexString","Utf16","Utf8","UtfHelpers","module","exports","__toCommonJS","fromArray","bytes","Uint8Array","Array","isArray","Error","arr","from","reduce","str","byte","toString","padStart","fromU8a","toArray","hexString","startsWith","slice","pairs","match","map","parseInt","toU8a","stringToU8a","u8a","lengthInBytes","offset","start","c1","c2","i","length","charCodeAt","diff","stringToNumberArray","u8aToString","end","t","String","fromCharCode","t2","numberArrayToString","stringToHexString","hexStringToString","len","c","stringToU16a","u16arr","Uint16Array","cp","codePointAt","s","fromCodePoint","u16aToString"],"sources":["C:\\Users\\khyy4\\Documents\\Code-Projects\\polkahack\\pookey\\node_modules\\index.ts"],"sourcesContent":["export const HexString = {\n  fromArray: (bytes: number[] | Uint8Array) => {\n    if (!(bytes instanceof Uint8Array) && !Array.isArray(bytes)) {\n      throw new Error(`HexString.fromArray: passed bytes obj is not an Array or Uint8Array: ${typeof bytes}, ${bytes}`)\n    }\n    const arr = bytes instanceof Uint8Array ? Array.from(bytes) : bytes\n    return '0x' + arr.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n  },\n  fromU8a: (bytes: number[] | Uint8Array) => HexString.fromArray(bytes),\n  toArray(hexString: string): number[] {\n    if (typeof hexString !== 'string') {\n      throw new Error(`HexString.toArray: passed string is not a string: ${typeof hexString}`)\n    }\n\n    const str: string = hexString.startsWith('0x') ? hexString.slice(2) : hexString\n    const pairs: RegExpMatchArray = str.match(/.{1,2}/g) || []\n    return pairs.map((byte) => parseInt(byte, 16))\n  },\n  toU8a: (hexString: string): Uint8Array => Uint8Array.from(HexString.toArray(hexString)),\n}\n\n\nexport const Utf8 = {\n  stringToU8a(str: string): Uint8Array {\n    const u8a = new Uint8Array(Utf8.lengthInBytes(str))\n\n    let offset = 0\n    const start = offset\n    let c1: number = 0 // character 1\n    let c2: number = 0 // character 2\n\n    let i = 0\n\n    while (i < str.length) {\n      c1 = str.charCodeAt(i)\n      if (c1 < 128) {\n        u8a[offset++] = c1\n      } else if (c1 < 2048) {\n        u8a[offset++] = c1 >> 6 | 192\n        u8a[offset++] = c1 & 63 | 128\n      } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = str.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {\n        c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF)\n        ++i\n        u8a[offset++] = c1 >> 18 | 240\n        u8a[offset++] = c1 >> 12 & 63 | 128\n        u8a[offset++] = c1 >> 6 & 63 | 128\n        u8a[offset++] = c1 & 63 | 128\n      } else {\n        u8a[offset++] = c1 >> 12 | 224\n        u8a[offset++] = c1 >> 6 & 63 | 128\n        u8a[offset++] = c1 & 63 | 128\n      }\n\n      i += 1\n    }\n    const diff = offset - start\n\n    return u8a\n  },\n  stringToNumberArray(str: string): number[] {\n    return Array.from(Utf8.stringToU8a(str))\n  },\n  u8aToString(u8a: Uint8Array): string {\n    let start = 0\n    let end = u8a.length\n\n    if (end - start < 1) {\n      return \"\"\n    }\n\n    let str = \"\"\n\n    let i = start\n\n    while (i < end) {\n      const t = u8a[i++]\n      if (t <= 0x7F) {\n        str += String.fromCharCode(t);\n      } else if (t >= 0xC0 && t < 0xE0) {\n        str += String.fromCharCode((t & 0x1F) << 6 | u8a[i++] & 0x3F)\n      } else if (t >= 0xE0 && t < 0xF0) {\n        str += String.fromCharCode((t & 0xF) << 12 | (u8a[i++] & 0x3F) << 6 | u8a[i++] & 0x3F)\n      } else if (t >= 0xF0) {\n        const t2 = ((t & 7) << 18 | (u8a[i++] & 0x3F) << 12 | (u8a[i++] & 0x3F) << 6 | u8a[i++] & 0x3F) - 0x10000\n        str += String.fromCharCode(0xD800 + (t2 >> 10))\n        str += String.fromCharCode(0xDC00 + (t2 & 0x3FF))\n      }\n    }\n\n    return str\n  },\n  numberArrayToString(arr: number[] | Uint8Array): string {\n    return Utf8.u8aToString(Uint8Array.from(arr))\n  },\n  stringToHexString(str: string): string {\n    return HexString.fromU8a(Utf8.stringToU8a(str))\n  },\n  hexStringToString(hexString: string): string {\n    return Utf8.u8aToString(HexString.toU8a(hexString))\n  },\n  lengthInBytes(str: string): number {\n    let len = 0\n    let c = 0\n\n    let i = 0\n\n    while (i < str.length) {\n      c = str.charCodeAt(i) as number\n      if (c < 128) {\n        len += 1\n      } else if (c < 2048) {\n        len += 2\n      } else if ((c & 0xFC00) === 0xD800 && ((str.charCodeAt(i + 1) as number) & 0xFC00) === 0xDC00) {\n        ++i\n        len += 4\n      } else {\n        len += 3\n      }\n\n      i += 1\n    }\n    return len\n  },\n}\n\n\nexport const Utf16 = {\n  stringToU16a(str: string): Uint16Array {\n    const u16arr = new Uint16Array(Utf16.lengthInBytes(str))\n\n    let i = 0\n\n    while (i < str.length) {\n      let cp = str.codePointAt(i) as number\n\n      if (cp <= 0xFFFF) {\n        u16arr[i++] = cp\n      } else {\n        cp -= 0x10000\n        u16arr[i++] = (cp >> 10) + 0xD800\n        u16arr[i++] = (cp % 0x400) + 0xDC00\n      }\n    }\n    return u16arr\n  },\n  stringToNumberArray(str: string): number[] {\n    return Array.from(Utf16.stringToU16a(str))\n  },\n  numberArrayToString(arr: number[] | Uint16Array) {\n    let i = 0\n    const len = arr.length\n    let s = ''\n\n    while (i < len - 1) {\n      const c1 = arr[i]\n      const c2 = arr[i + 1]\n\n      if (c1 >= 0xD800 && c1 <= 0xDFFF) {\n        if (c2 >= 0xDC00 && c2 <= 0xDFFF) {\n          s += String.fromCodePoint((c1 - 0xD800) * 0x400 + c2 - 0xDC00 + 0x10000)\n          i += 2\n        } else {\n          throw new Error(`invalid UTF16 sequence: first u16 is ${c1}, second u16 is ${c2}`)\n        }\n      } else {\n        s += String.fromCodePoint(c1)\n        i += 1\n      }\n    }\n\n    if (i < len) {\n      s += String.fromCodePoint(arr[len - 1])\n    }\n\n    return s\n  },\n  u16aToString(arr: number[] | Uint16Array): string {\n    return Utf16.numberArrayToString(arr)\n  },\n  lengthInBytes(str: string): number {\n    let i = 0\n\n    while (i < str.length) {\n      i += (str.codePointAt(i) as number <= 0xFFFF) ? 1 : 2\n    }\n\n    return i\n  },\n}\n\nexport const UtfHelpers = {\n  HexString,\n  Utf8,\n  Utf16,\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAAA,mBAAA;AAAAC,QAAA,CAAAD,mBAAA;EAAAE,SAAA,EAAAA,CAAA,KAAAA,SAAA;EAAAC,KAAA,EAAAA,CAAA,KAAAA,KAAA;EAAAC,IAAA,EAAAA,CAAA,KAAAA,IAAA;EAAAC,UAAA,EAAAA,CAAA,KAAAA;AAAA;AAAAC,MAAA,CAAAC,OAAA,GAAAC,YAAA,CAAAR,mBAAA;AAAO,IAAME,SAAA,GAAY;EACvBO,SAAA,EAAYC,KAAA,IAAiC;IAC3C,IAAI,EAAEA,KAAA,YAAiBC,UAAA,KAAe,CAACC,KAAA,CAAMC,OAAA,CAAQH,KAAK,GAAG;MAC3D,MAAM,IAAII,KAAA,CAAM,wEAAwE,OAAOJ,KAAA,KAAUA,KAAA,EAAO;IAClH;IACA,MAAMK,GAAA,GAAML,KAAA,YAAiBC,UAAA,GAAaC,KAAA,CAAMI,IAAA,CAAKN,KAAK,IAAIA,KAAA;IAC9D,OAAO,OAAOK,GAAA,CAAIE,MAAA,CAAO,CAACC,GAAA,EAAKC,IAAA,KAASD,GAAA,GAAMC,IAAA,CAAKC,QAAA,CAAS,EAAE,EAAEC,QAAA,CAAS,GAAG,GAAG,GAAG,EAAE;EACtF;EACAC,OAAA,EAAUZ,KAAA,IAAiCR,SAAA,CAAUO,SAAA,CAAUC,KAAK;EACpEa,QAAQC,SAAA,EAA6B;IACnC,IAAI,OAAOA,SAAA,KAAc,UAAU;MACjC,MAAM,IAAIV,KAAA,CAAM,qDAAqD,OAAOU,SAAA,EAAW;IACzF;IAEA,MAAMN,GAAA,GAAcM,SAAA,CAAUC,UAAA,CAAW,IAAI,IAAID,SAAA,CAAUE,KAAA,CAAM,CAAC,IAAIF,SAAA;IACtE,MAAMG,KAAA,GAA0BT,GAAA,CAAIU,KAAA,CAAM,SAAS,KAAK,EAAC;IACzD,OAAOD,KAAA,CAAME,GAAA,CAAKV,IAAA,IAASW,QAAA,CAASX,IAAA,EAAM,EAAE,CAAC;EAC/C;EACAY,KAAA,EAAQP,SAAA,IAAkCb,UAAA,CAAWK,IAAA,CAAKd,SAAA,CAAUqB,OAAA,CAAQC,SAAS,CAAC;AACxF;AAGO,IAAMpB,IAAA,GAAO;EAClB4B,YAAYd,GAAA,EAAyB;IACnC,MAAMe,GAAA,GAAM,IAAItB,UAAA,CAAWP,IAAA,CAAK8B,aAAA,CAAchB,GAAG,CAAC;IAElD,IAAIiB,MAAA,GAAS;IACb,MAAMC,KAAA,GAAQD,MAAA;IACd,IAAIE,EAAA,GAAa;IACjB,IAAIC,EAAA,GAAa;IAEjB,IAAIC,CAAA,GAAI;IAER,OAAOA,CAAA,GAAIrB,GAAA,CAAIsB,MAAA,EAAQ;MACrBH,EAAA,GAAKnB,GAAA,CAAIuB,UAAA,CAAWF,CAAC;MACrB,IAAIF,EAAA,GAAK,KAAK;QACZJ,GAAA,CAAIE,MAAA,MAAYE,EAAA;MAClB,WAAWA,EAAA,GAAK,MAAM;QACpBJ,GAAA,CAAIE,MAAA,MAAYE,EAAA,IAAM,IAAI;QAC1BJ,GAAA,CAAIE,MAAA,MAAYE,EAAA,GAAK,KAAK;MAC5B,YAAYA,EAAA,GAAK,WAAY,WAAYC,EAAA,GAAKpB,GAAA,CAAIuB,UAAA,CAAWF,CAAA,GAAI,CAAC,KAAK,WAAY,OAAQ;QACzFF,EAAA,GAAK,UAAYA,EAAA,GAAK,SAAW,OAAOC,EAAA,GAAK;QAC7C,EAAEC,CAAA;QACFN,GAAA,CAAIE,MAAA,MAAYE,EAAA,IAAM,KAAK;QAC3BJ,GAAA,CAAIE,MAAA,MAAYE,EAAA,IAAM,KAAK,KAAK;QAChCJ,GAAA,CAAIE,MAAA,MAAYE,EAAA,IAAM,IAAI,KAAK;QAC/BJ,GAAA,CAAIE,MAAA,MAAYE,EAAA,GAAK,KAAK;MAC5B,OAAO;QACLJ,GAAA,CAAIE,MAAA,MAAYE,EAAA,IAAM,KAAK;QAC3BJ,GAAA,CAAIE,MAAA,MAAYE,EAAA,IAAM,IAAI,KAAK;QAC/BJ,GAAA,CAAIE,MAAA,MAAYE,EAAA,GAAK,KAAK;MAC5B;MAEAE,CAAA,IAAK;IACP;IACA,MAAMG,IAAA,GAAOP,MAAA,GAASC,KAAA;IAEtB,OAAOH,GAAA;EACT;EACAU,oBAAoBzB,GAAA,EAAuB;IACzC,OAAON,KAAA,CAAMI,IAAA,CAAKZ,IAAA,CAAK4B,WAAA,CAAYd,GAAG,CAAC;EACzC;EACA0B,YAAYX,GAAA,EAAyB;IACnC,IAAIG,KAAA,GAAQ;IACZ,IAAIS,GAAA,GAAMZ,GAAA,CAAIO,MAAA;IAEd,IAAIK,GAAA,GAAMT,KAAA,GAAQ,GAAG;MACnB,OAAO;IACT;IAEA,IAAIlB,GAAA,GAAM;IAEV,IAAIqB,CAAA,GAAIH,KAAA;IAER,OAAOG,CAAA,GAAIM,GAAA,EAAK;MACd,MAAMC,CAAA,GAAIb,GAAA,CAAIM,CAAA;MACd,IAAIO,CAAA,IAAK,KAAM;QACb5B,GAAA,IAAO6B,MAAA,CAAOC,YAAA,CAAaF,CAAC;MAC9B,WAAWA,CAAA,IAAK,OAAQA,CAAA,GAAI,KAAM;QAChC5B,GAAA,IAAO6B,MAAA,CAAOC,YAAA,EAAcF,CAAA,GAAI,OAAS,IAAIb,GAAA,CAAIM,CAAA,MAAO,EAAI;MAC9D,WAAWO,CAAA,IAAK,OAAQA,CAAA,GAAI,KAAM;QAChC5B,GAAA,IAAO6B,MAAA,CAAOC,YAAA,EAAcF,CAAA,GAAI,OAAQ,MAAMb,GAAA,CAAIM,CAAA,MAAO,OAAS,IAAIN,GAAA,CAAIM,CAAA,MAAO,EAAI;MACvF,WAAWO,CAAA,IAAK,KAAM;QACpB,MAAMG,EAAA,KAAOH,CAAA,GAAI,MAAM,MAAMb,GAAA,CAAIM,CAAA,MAAO,OAAS,MAAMN,GAAA,CAAIM,CAAA,MAAO,OAAS,IAAIN,GAAA,CAAIM,CAAA,MAAO,MAAQ;QAClGrB,GAAA,IAAO6B,MAAA,CAAOC,YAAA,CAAa,SAAUC,EAAA,IAAM,GAAG;QAC9C/B,GAAA,IAAO6B,MAAA,CAAOC,YAAA,CAAa,SAAUC,EAAA,GAAK,KAAM;MAClD;IACF;IAEA,OAAO/B,GAAA;EACT;EACAgC,oBAAoBnC,GAAA,EAAoC;IACtD,OAAOX,IAAA,CAAKwC,WAAA,CAAYjC,UAAA,CAAWK,IAAA,CAAKD,GAAG,CAAC;EAC9C;EACAoC,kBAAkBjC,GAAA,EAAqB;IACrC,OAAOhB,SAAA,CAAUoB,OAAA,CAAQlB,IAAA,CAAK4B,WAAA,CAAYd,GAAG,CAAC;EAChD;EACAkC,kBAAkB5B,SAAA,EAA2B;IAC3C,OAAOpB,IAAA,CAAKwC,WAAA,CAAY1C,SAAA,CAAU6B,KAAA,CAAMP,SAAS,CAAC;EACpD;EACAU,cAAchB,GAAA,EAAqB;IACjC,IAAImC,GAAA,GAAM;IACV,IAAIC,CAAA,GAAI;IAER,IAAIf,CAAA,GAAI;IAER,OAAOA,CAAA,GAAIrB,GAAA,CAAIsB,MAAA,EAAQ;MACrBc,CAAA,GAAIpC,GAAA,CAAIuB,UAAA,CAAWF,CAAC;MACpB,IAAIe,CAAA,GAAI,KAAK;QACXD,GAAA,IAAO;MACT,WAAWC,CAAA,GAAI,MAAM;QACnBD,GAAA,IAAO;MACT,YAAYC,CAAA,GAAI,WAAY,UAAYpC,GAAA,CAAIuB,UAAA,CAAWF,CAAA,GAAI,CAAC,IAAe,WAAY,OAAQ;QAC7F,EAAEA,CAAA;QACFc,GAAA,IAAO;MACT,OAAO;QACLA,GAAA,IAAO;MACT;MAEAd,CAAA,IAAK;IACP;IACA,OAAOc,GAAA;EACT;AACF;AAGO,IAAMlD,KAAA,GAAQ;EACnBoD,aAAarC,GAAA,EAA0B;IACrC,MAAMsC,MAAA,GAAS,IAAIC,WAAA,CAAYtD,KAAA,CAAM+B,aAAA,CAAchB,GAAG,CAAC;IAEvD,IAAIqB,CAAA,GAAI;IAER,OAAOA,CAAA,GAAIrB,GAAA,CAAIsB,MAAA,EAAQ;MACrB,IAAIkB,EAAA,GAAKxC,GAAA,CAAIyC,WAAA,CAAYpB,CAAC;MAE1B,IAAImB,EAAA,IAAM,OAAQ;QAChBF,MAAA,CAAOjB,CAAA,MAAOmB,EAAA;MAChB,OAAO;QACLA,EAAA,IAAM;QACNF,MAAA,CAAOjB,CAAA,OAAQmB,EAAA,IAAM,MAAM;QAC3BF,MAAA,CAAOjB,CAAA,MAAQmB,EAAA,GAAK,OAAS;MAC/B;IACF;IACA,OAAOF,MAAA;EACT;EACAb,oBAAoBzB,GAAA,EAAuB;IACzC,OAAON,KAAA,CAAMI,IAAA,CAAKb,KAAA,CAAMoD,YAAA,CAAarC,GAAG,CAAC;EAC3C;EACAgC,oBAAoBnC,GAAA,EAA6B;IAC/C,IAAIwB,CAAA,GAAI;IACR,MAAMc,GAAA,GAAMtC,GAAA,CAAIyB,MAAA;IAChB,IAAIoB,CAAA,GAAI;IAER,OAAOrB,CAAA,GAAIc,GAAA,GAAM,GAAG;MAClB,MAAMhB,EAAA,GAAKtB,GAAA,CAAIwB,CAAA;MACf,MAAMD,EAAA,GAAKvB,GAAA,CAAIwB,CAAA,GAAI;MAEnB,IAAIF,EAAA,IAAM,SAAUA,EAAA,IAAM,OAAQ;QAChC,IAAIC,EAAA,IAAM,SAAUA,EAAA,IAAM,OAAQ;UAChCsB,CAAA,IAAKb,MAAA,CAAOc,aAAA,EAAexB,EAAA,GAAK,SAAU,OAAQC,EAAA,GAAK,QAAS,KAAO;UACvEC,CAAA,IAAK;QACP,OAAO;UACL,MAAM,IAAIzB,KAAA,CAAM,wCAAwCuB,EAAA,mBAAqBC,EAAA,EAAI;QACnF;MACF,OAAO;QACLsB,CAAA,IAAKb,MAAA,CAAOc,aAAA,CAAcxB,EAAE;QAC5BE,CAAA,IAAK;MACP;IACF;IAEA,IAAIA,CAAA,GAAIc,GAAA,EAAK;MACXO,CAAA,IAAKb,MAAA,CAAOc,aAAA,CAAc9C,GAAA,CAAIsC,GAAA,GAAM,EAAE;IACxC;IAEA,OAAOO,CAAA;EACT;EACAE,aAAa/C,GAAA,EAAqC;IAChD,OAAOZ,KAAA,CAAM+C,mBAAA,CAAoBnC,GAAG;EACtC;EACAmB,cAAchB,GAAA,EAAqB;IACjC,IAAIqB,CAAA,GAAI;IAER,OAAOA,CAAA,GAAIrB,GAAA,CAAIsB,MAAA,EAAQ;MACrBD,CAAA,IAAMrB,GAAA,CAAIyC,WAAA,CAAYpB,CAAC,KAAe,QAAU,IAAI;IACtD;IAEA,OAAOA,CAAA;EACT;AACF;AAEO,IAAMlC,UAAA,GAAa;EACxBH,SAAA;EACAE,IAAA;EACAD;AACF","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
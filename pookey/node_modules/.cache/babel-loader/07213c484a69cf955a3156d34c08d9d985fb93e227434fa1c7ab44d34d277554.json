{"ast":null,"code":"import { combineLatest, map, of, switchMap } from 'rxjs';\nimport { BN_BILLION, BN_ZERO, objectSpread } from '@polkadot/util';\nimport { firstMemo, memo } from '../util/index.js';\nfunction extractCompatRewards(claimedRewardsEras, ledger) {\n  const l = ledger ? (ledger.legacyClaimedRewards || ledger.claimedRewards).toArray() : [];\n  return claimedRewardsEras.toArray().concat(l);\n}\nfunction parseRewards(api, stashId, [erasPoints, erasPrefs, erasRewards], exposures) {\n  return exposures.map(({\n    era,\n    isEmpty,\n    isValidator,\n    nominating,\n    validators: eraValidators\n  }) => {\n    const {\n      eraPoints,\n      validators: allValPoints\n    } = erasPoints.find(p => p.era.eq(era)) || {\n      eraPoints: BN_ZERO,\n      validators: {}\n    };\n    const {\n      eraReward\n    } = erasRewards.find(r => r.era.eq(era)) || {\n      eraReward: api.registry.createType('Balance')\n    };\n    const {\n      validators: allValPrefs\n    } = erasPrefs.find(p => p.era.eq(era)) || {\n      validators: {}\n    };\n    const validators = {};\n    const stakerId = stashId.toString();\n    Object.entries(eraValidators).forEach(([validatorId, exposure]) => {\n      const valPoints = allValPoints[validatorId] || BN_ZERO;\n      const valComm = allValPrefs[validatorId]?.commission.unwrap() || BN_ZERO;\n      const expTotal = exposure.total ? exposure.total?.unwrap() : exposure.pageTotal ? exposure.pageTotal?.unwrap() : BN_ZERO;\n      let avail = BN_ZERO;\n      let value;\n      if (!(expTotal.isZero() || valPoints.isZero() || eraPoints.isZero())) {\n        avail = eraReward.mul(valPoints).div(eraPoints);\n        const valCut = valComm.mul(avail).div(BN_BILLION);\n        let staked;\n        if (validatorId === stakerId) {\n          if (exposure.own) {\n            staked = exposure.own.unwrap();\n          } else {\n            const expAccount = exposure.others.find(({\n              who\n            }) => who.eq(validatorId));\n            staked = expAccount ? expAccount.value.unwrap() : BN_ZERO;\n          }\n        } else {\n          const stakerExp = exposure.others.find(({\n            who\n          }) => who.eq(stakerId));\n          staked = stakerExp ? stakerExp.value.unwrap() : BN_ZERO;\n        }\n        value = avail.sub(valCut).imul(staked).div(expTotal).iadd(validatorId === stakerId ? valCut : BN_ZERO);\n      }\n      validators[validatorId] = {\n        total: api.registry.createType('Balance', avail),\n        value: api.registry.createType('Balance', value)\n      };\n    });\n    return {\n      era,\n      eraReward,\n      isEmpty,\n      isValidator,\n      nominating,\n      validators\n    };\n  });\n}\nfunction allUniqValidators(rewards) {\n  return rewards.reduce(([all, perStash], rewards) => {\n    const uniq = [];\n    perStash.push(uniq);\n    rewards.forEach(({\n      validators\n    }) => Object.keys(validators).forEach(validatorId => {\n      if (!uniq.includes(validatorId)) {\n        uniq.push(validatorId);\n        if (!all.includes(validatorId)) {\n          all.push(validatorId);\n        }\n      }\n    }));\n    return [all, perStash];\n  }, [[], []]);\n}\nfunction removeClaimed(validators, queryValidators, reward, claimedRewardsEras) {\n  const rm = [];\n  Object.keys(reward.validators).forEach(validatorId => {\n    const index = validators.indexOf(validatorId);\n    if (index !== -1) {\n      const valLedger = queryValidators[index].stakingLedger;\n      if (extractCompatRewards(claimedRewardsEras, valLedger).some(e => reward.era.eq(e))) {\n        rm.push(validatorId);\n      }\n    }\n  });\n  rm.forEach(validatorId => {\n    delete reward.validators[validatorId];\n  });\n}\nfunction filterRewards(eras, valInfo, {\n  claimedRewardsEras,\n  rewards,\n  stakingLedger\n}) {\n  const filter = eras.filter(e => !extractCompatRewards(claimedRewardsEras, stakingLedger).some(s => s.eq(e)));\n  const validators = valInfo.map(([v]) => v);\n  const queryValidators = valInfo.map(([, q]) => q);\n  return rewards.filter(({\n    isEmpty\n  }) => !isEmpty).filter(reward => {\n    if (!filter.some(e => reward.era.eq(e))) {\n      return false;\n    }\n    removeClaimed(validators, queryValidators, reward, claimedRewardsEras);\n    return true;\n  }).filter(({\n    validators\n  }) => Object.keys(validators).length !== 0).map(reward => objectSpread({}, reward, {\n    nominators: reward.nominating.filter(n => reward.validators[n.validatorId])\n  }));\n}\nexport function _stakerRewardsEras(instanceId, api) {\n  return memo(instanceId, (eras, withActive = false) => combineLatest([api.derive.staking._erasPoints(eras, withActive), api.derive.staking._erasPrefs(eras, withActive), api.derive.staking._erasRewards(eras, withActive)]));\n}\nexport function _stakerRewards(instanceId, api) {\n  return memo(instanceId, (accountIds, eras, withActive = false) => {\n    // Ensures that when number or string types are passed in they are sanitized\n    // Ref: https://github.com/polkadot-js/api/issues/5910\n    const sanitizedEras = eras.map(e => typeof e === 'number' || typeof e === 'string' ? api.registry.createType('u32', e) : e);\n    return combineLatest([api.derive.staking.queryMulti(accountIds, {\n      withClaimedRewardsEras: true,\n      withLedger: true\n    }), api.derive.staking._stakerExposures(accountIds, sanitizedEras, withActive), api.derive.staking._stakerRewardsEras(sanitizedEras, withActive)]).pipe(switchMap(([queries, exposures, erasResult]) => {\n      const allRewards = queries.map(({\n        claimedRewardsEras,\n        stakingLedger,\n        stashId\n      }, index) => !stashId || !stakingLedger && !claimedRewardsEras ? [] : parseRewards(api, stashId, erasResult, exposures[index]));\n      if (withActive) {\n        return of(allRewards);\n      }\n      const [allValidators, stashValidators] = allUniqValidators(allRewards);\n      return api.derive.staking.queryMulti(allValidators, {\n        withClaimedRewardsEras: true,\n        withLedger: true\n      }).pipe(map(queriedVals => queries.map(({\n        claimedRewardsEras,\n        stakingLedger\n      }, index) => filterRewards(eras, stashValidators[index].map(validatorId => [validatorId, queriedVals.find(q => q.accountId.eq(validatorId))]).filter(v => !!v[1]), {\n        claimedRewardsEras,\n        rewards: allRewards[index],\n        stakingLedger\n      }))));\n    }));\n  });\n}\nexport const stakerRewards = /*#__PURE__*/firstMemo((api, accountId, withActive) => api.derive.staking.erasHistoric(withActive).pipe(switchMap(eras => api.derive.staking._stakerRewards([accountId], eras, withActive))));\nexport function stakerRewardsMultiEras(instanceId, api) {\n  return memo(instanceId, (accountIds, eras) => accountIds.length && eras.length ? api.derive.staking._stakerRewards(accountIds, eras, false) : of([]));\n}\nexport function stakerRewardsMulti(instanceId, api) {\n  return memo(instanceId, (accountIds, withActive = false) => api.derive.staking.erasHistoric(withActive).pipe(switchMap(eras => api.derive.staking.stakerRewardsMultiEras(accountIds, eras))));\n}","map":{"version":3,"names":["combineLatest","map","of","switchMap","BN_BILLION","BN_ZERO","objectSpread","firstMemo","memo","extractCompatRewards","claimedRewardsEras","ledger","l","legacyClaimedRewards","claimedRewards","toArray","concat","parseRewards","api","stashId","erasPoints","erasPrefs","erasRewards","exposures","era","isEmpty","isValidator","nominating","validators","eraValidators","eraPoints","allValPoints","find","p","eq","eraReward","r","registry","createType","allValPrefs","stakerId","toString","Object","entries","forEach","validatorId","exposure","valPoints","valComm","commission","unwrap","expTotal","total","pageTotal","avail","value","isZero","mul","div","valCut","staked","own","expAccount","others","who","stakerExp","sub","imul","iadd","allUniqValidators","rewards","reduce","all","perStash","uniq","push","keys","includes","removeClaimed","queryValidators","reward","rm","index","indexOf","valLedger","stakingLedger","some","e","filterRewards","eras","valInfo","filter","s","v","q","length","nominators","n","_stakerRewardsEras","instanceId","withActive","derive","staking","_erasPoints","_erasPrefs","_erasRewards","_stakerRewards","accountIds","sanitizedEras","queryMulti","withClaimedRewardsEras","withLedger","_stakerExposures","pipe","queries","erasResult","allRewards","allValidators","stashValidators","queriedVals","accountId","stakerRewards","erasHistoric","stakerRewardsMultiEras","stakerRewardsMulti"],"sources":["C:/Users/khyy4/Documents/Code-Projects/polkahack/pookey/node_modules/@polkadot/api-derive/staking/stakerRewards.js"],"sourcesContent":["import { combineLatest, map, of, switchMap } from 'rxjs';\nimport { BN_BILLION, BN_ZERO, objectSpread } from '@polkadot/util';\nimport { firstMemo, memo } from '../util/index.js';\nfunction extractCompatRewards(claimedRewardsEras, ledger) {\n    const l = ledger\n        ? (ledger.legacyClaimedRewards ||\n            ledger.claimedRewards).toArray()\n        : [];\n    return claimedRewardsEras.toArray().concat(l);\n}\nfunction parseRewards(api, stashId, [erasPoints, erasPrefs, erasRewards], exposures) {\n    return exposures.map(({ era, isEmpty, isValidator, nominating, validators: eraValidators }) => {\n        const { eraPoints, validators: allValPoints } = erasPoints.find((p) => p.era.eq(era)) || { eraPoints: BN_ZERO, validators: {} };\n        const { eraReward } = erasRewards.find((r) => r.era.eq(era)) || { eraReward: api.registry.createType('Balance') };\n        const { validators: allValPrefs } = erasPrefs.find((p) => p.era.eq(era)) || { validators: {} };\n        const validators = {};\n        const stakerId = stashId.toString();\n        Object.entries(eraValidators).forEach(([validatorId, exposure]) => {\n            const valPoints = allValPoints[validatorId] || BN_ZERO;\n            const valComm = allValPrefs[validatorId]?.commission.unwrap() || BN_ZERO;\n            const expTotal = exposure.total\n                ? exposure.total?.unwrap()\n                : exposure.pageTotal\n                    ? exposure.pageTotal?.unwrap()\n                    : BN_ZERO;\n            let avail = BN_ZERO;\n            let value;\n            if (!(expTotal.isZero() || valPoints.isZero() || eraPoints.isZero())) {\n                avail = eraReward.mul(valPoints).div(eraPoints);\n                const valCut = valComm.mul(avail).div(BN_BILLION);\n                let staked;\n                if (validatorId === stakerId) {\n                    if (exposure.own) {\n                        staked = exposure.own.unwrap();\n                    }\n                    else {\n                        const expAccount = exposure.others.find(({ who }) => who.eq(validatorId));\n                        staked = expAccount\n                            ? expAccount.value.unwrap()\n                            : BN_ZERO;\n                    }\n                }\n                else {\n                    const stakerExp = exposure.others.find(({ who }) => who.eq(stakerId));\n                    staked = stakerExp\n                        ? stakerExp.value.unwrap()\n                        : BN_ZERO;\n                }\n                value = avail.sub(valCut).imul(staked).div(expTotal).iadd(validatorId === stakerId ? valCut : BN_ZERO);\n            }\n            validators[validatorId] = {\n                total: api.registry.createType('Balance', avail),\n                value: api.registry.createType('Balance', value)\n            };\n        });\n        return {\n            era,\n            eraReward,\n            isEmpty,\n            isValidator,\n            nominating,\n            validators\n        };\n    });\n}\nfunction allUniqValidators(rewards) {\n    return rewards.reduce(([all, perStash], rewards) => {\n        const uniq = [];\n        perStash.push(uniq);\n        rewards.forEach(({ validators }) => Object.keys(validators).forEach((validatorId) => {\n            if (!uniq.includes(validatorId)) {\n                uniq.push(validatorId);\n                if (!all.includes(validatorId)) {\n                    all.push(validatorId);\n                }\n            }\n        }));\n        return [all, perStash];\n    }, [[], []]);\n}\nfunction removeClaimed(validators, queryValidators, reward, claimedRewardsEras) {\n    const rm = [];\n    Object.keys(reward.validators).forEach((validatorId) => {\n        const index = validators.indexOf(validatorId);\n        if (index !== -1) {\n            const valLedger = queryValidators[index].stakingLedger;\n            if (extractCompatRewards(claimedRewardsEras, valLedger).some((e) => reward.era.eq(e))) {\n                rm.push(validatorId);\n            }\n        }\n    });\n    rm.forEach((validatorId) => {\n        delete reward.validators[validatorId];\n    });\n}\nfunction filterRewards(eras, valInfo, { claimedRewardsEras, rewards, stakingLedger }) {\n    const filter = eras.filter((e) => !extractCompatRewards(claimedRewardsEras, stakingLedger).some((s) => s.eq(e)));\n    const validators = valInfo.map(([v]) => v);\n    const queryValidators = valInfo.map(([, q]) => q);\n    return rewards\n        .filter(({ isEmpty }) => !isEmpty)\n        .filter((reward) => {\n        if (!filter.some((e) => reward.era.eq(e))) {\n            return false;\n        }\n        removeClaimed(validators, queryValidators, reward, claimedRewardsEras);\n        return true;\n    })\n        .filter(({ validators }) => Object.keys(validators).length !== 0)\n        .map((reward) => objectSpread({}, reward, {\n        nominators: reward.nominating.filter((n) => reward.validators[n.validatorId])\n    }));\n}\nexport function _stakerRewardsEras(instanceId, api) {\n    return memo(instanceId, (eras, withActive = false) => combineLatest([\n        api.derive.staking._erasPoints(eras, withActive),\n        api.derive.staking._erasPrefs(eras, withActive),\n        api.derive.staking._erasRewards(eras, withActive)\n    ]));\n}\nexport function _stakerRewards(instanceId, api) {\n    return memo(instanceId, (accountIds, eras, withActive = false) => {\n        // Ensures that when number or string types are passed in they are sanitized\n        // Ref: https://github.com/polkadot-js/api/issues/5910\n        const sanitizedEras = eras.map((e) => typeof e === 'number' || typeof e === 'string' ? api.registry.createType('u32', e) : e);\n        return combineLatest([\n            api.derive.staking.queryMulti(accountIds, { withClaimedRewardsEras: true, withLedger: true }),\n            api.derive.staking._stakerExposures(accountIds, sanitizedEras, withActive),\n            api.derive.staking._stakerRewardsEras(sanitizedEras, withActive)\n        ]).pipe(switchMap(([queries, exposures, erasResult]) => {\n            const allRewards = queries.map(({ claimedRewardsEras, stakingLedger, stashId }, index) => (!stashId || (!stakingLedger && !claimedRewardsEras))\n                ? []\n                : parseRewards(api, stashId, erasResult, exposures[index]));\n            if (withActive) {\n                return of(allRewards);\n            }\n            const [allValidators, stashValidators] = allUniqValidators(allRewards);\n            return api.derive.staking.queryMulti(allValidators, { withClaimedRewardsEras: true, withLedger: true }).pipe(map((queriedVals) => queries.map(({ claimedRewardsEras, stakingLedger }, index) => filterRewards(eras, stashValidators[index]\n                .map((validatorId) => [\n                validatorId,\n                queriedVals.find((q) => q.accountId.eq(validatorId))\n            ])\n                .filter((v) => !!v[1]), {\n                claimedRewardsEras,\n                rewards: allRewards[index],\n                stakingLedger\n            }))));\n        }));\n    });\n}\nexport const stakerRewards = /*#__PURE__*/ firstMemo((api, accountId, withActive) => api.derive.staking.erasHistoric(withActive).pipe(switchMap((eras) => api.derive.staking._stakerRewards([accountId], eras, withActive))));\nexport function stakerRewardsMultiEras(instanceId, api) {\n    return memo(instanceId, (accountIds, eras) => accountIds.length && eras.length\n        ? api.derive.staking._stakerRewards(accountIds, eras, false)\n        : of([]));\n}\nexport function stakerRewardsMulti(instanceId, api) {\n    return memo(instanceId, (accountIds, withActive = false) => api.derive.staking.erasHistoric(withActive).pipe(switchMap((eras) => api.derive.staking.stakerRewardsMultiEras(accountIds, eras))));\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
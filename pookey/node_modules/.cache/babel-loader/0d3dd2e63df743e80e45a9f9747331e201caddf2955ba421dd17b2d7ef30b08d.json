{"ast":null,"code":"import { Option, Struct } from '@polkadot/types-codec';\nimport { objectProperty, objectSpread, u8aToHex } from '@polkadot/util';\nconst knownTypes = {\n  address: 'Address',\n  assetId: 'Option<TAssetConversion>',\n  blockHash: 'Hash',\n  blockNumber: 'BlockNumber',\n  era: 'ExtrinsicEra',\n  genesisHash: 'Hash',\n  metadataHash: 'Option<[u8;32]>',\n  method: 'Call',\n  mode: 'u8',\n  nonce: 'Compact<Index>',\n  runtimeVersion: 'RuntimeVersion',\n  signedExtensions: 'Vec<Text>',\n  tip: 'Compact<Balance>',\n  version: 'u8'\n};\n/**\n * @name GenericSignerPayload\n * @description\n * A generic signer payload that can be used for serialization between API and signer\n */\nexport class GenericSignerPayload extends Struct {\n  __internal__extraTypes;\n  constructor(registry, value) {\n    const extensionTypes = objectSpread({}, registry.getSignedExtensionTypes(), registry.getSignedExtensionExtra());\n    super(registry, objectSpread({}, extensionTypes, knownTypes, {\n      withSignedTransaction: 'bool'\n    }), value);\n    this.__internal__extraTypes = {};\n    const getter = key => this.get(key);\n    // add all extras that are not in the base types\n    for (const [key, type] of Object.entries(extensionTypes)) {\n      if (!knownTypes[key]) {\n        this.__internal__extraTypes[key] = type;\n      }\n      objectProperty(this, key, getter);\n    }\n  }\n  get address() {\n    return this.getT('address');\n  }\n  get blockHash() {\n    return this.getT('blockHash');\n  }\n  get blockNumber() {\n    return this.getT('blockNumber');\n  }\n  get era() {\n    return this.getT('era');\n  }\n  get genesisHash() {\n    return this.getT('genesisHash');\n  }\n  get method() {\n    return this.getT('method');\n  }\n  get nonce() {\n    return this.getT('nonce');\n  }\n  get runtimeVersion() {\n    return this.getT('runtimeVersion');\n  }\n  get signedExtensions() {\n    return this.getT('signedExtensions');\n  }\n  get tip() {\n    return this.getT('tip');\n  }\n  get assetId() {\n    return this.getT('assetId');\n  }\n  get version() {\n    return this.getT('version');\n  }\n  get mode() {\n    return this.getT('mode');\n  }\n  get metadataHash() {\n    return this.getT('metadataHash');\n  }\n  get withSignedTransaction() {\n    const val = this.getT('withSignedTransaction');\n    return val.isTrue;\n  }\n  /**\n   * @description Creates an representation of the structure as an ISignerPayload JSON\n   */\n  toPayload() {\n    const result = {};\n    const keys = Object.keys(this.__internal__extraTypes);\n    // add any explicit overrides we may have\n    for (let i = 0, count = keys.length; i < count; i++) {\n      const key = keys[i];\n      const value = this.getT(key);\n      // Don't include Option.isNone\n      if (!(value instanceof Option) || value.isSome) {\n        // NOTE In the spread below we convert (mostly) to Hex to align\n        // with the typings. In the case of \"unknown\" fields, we use the\n        // primitive toJSON conversion (which is serializable). Technically\n        // we can include isNone in here as well (\"null\" is allowed), however\n        // for empty fields we just skip it completely (historical compat)\n        result[key] = value.toJSON();\n      }\n    }\n    return objectSpread(result, {\n      // the known defaults as managed explicitly and has different\n      // formatting in cases, e.g. we mostly expose a hex format here\n      address: this.address.toString(),\n      assetId: this.assetId ? this.assetId.toJSON() : null,\n      blockHash: this.blockHash.toHex(),\n      blockNumber: this.blockNumber.toHex(),\n      era: this.era.toHex(),\n      genesisHash: this.genesisHash.toHex(),\n      metadataHash: this.metadataHash.isSome ? this.metadataHash.toHex() : null,\n      method: this.method.toHex(),\n      mode: this.mode.toNumber(),\n      nonce: this.nonce.toHex(),\n      signedExtensions: this.signedExtensions.map(e => e.toString()),\n      specVersion: this.runtimeVersion.specVersion.toHex(),\n      tip: this.tip.toHex(),\n      transactionVersion: this.runtimeVersion.transactionVersion.toHex(),\n      version: this.version.toNumber(),\n      withSignedTransaction: this.withSignedTransaction\n    });\n  }\n  /**\n   * @description Creates a representation of the payload in raw Exrinsic form\n   */\n  toRaw() {\n    const payload = this.toPayload();\n    const data = u8aToHex(this.registry.createTypeUnsafe('ExtrinsicPayload', [payload, {\n      version: payload.version\n    }])\n    // NOTE Explicitly pass the bare flag so the method is encoded un-prefixed (non-decodable, for signing only)\n    .toU8a({\n      method: true\n    }));\n    return {\n      address: payload.address,\n      data,\n      type: 'payload'\n    };\n  }\n}","map":{"version":3,"names":["Option","Struct","objectProperty","objectSpread","u8aToHex","knownTypes","address","assetId","blockHash","blockNumber","era","genesisHash","metadataHash","method","mode","nonce","runtimeVersion","signedExtensions","tip","version","GenericSignerPayload","__internal__extraTypes","constructor","registry","value","extensionTypes","getSignedExtensionTypes","getSignedExtensionExtra","withSignedTransaction","getter","key","get","type","Object","entries","getT","val","isTrue","toPayload","result","keys","i","count","length","isSome","toJSON","toString","toHex","toNumber","map","e","specVersion","transactionVersion","toRaw","payload","data","createTypeUnsafe","toU8a"],"sources":["C:/Users/khyy4/Documents/Code-Projects/polkahack/pookey/node_modules/@polkadot/api/node_modules/@polkadot/types/extrinsic/SignerPayload.js"],"sourcesContent":["import { Option, Struct } from '@polkadot/types-codec';\nimport { objectProperty, objectSpread, u8aToHex } from '@polkadot/util';\nconst knownTypes = {\n    address: 'Address',\n    assetId: 'Option<TAssetConversion>',\n    blockHash: 'Hash',\n    blockNumber: 'BlockNumber',\n    era: 'ExtrinsicEra',\n    genesisHash: 'Hash',\n    metadataHash: 'Option<[u8;32]>',\n    method: 'Call',\n    mode: 'u8',\n    nonce: 'Compact<Index>',\n    runtimeVersion: 'RuntimeVersion',\n    signedExtensions: 'Vec<Text>',\n    tip: 'Compact<Balance>',\n    version: 'u8'\n};\n/**\n * @name GenericSignerPayload\n * @description\n * A generic signer payload that can be used for serialization between API and signer\n */\nexport class GenericSignerPayload extends Struct {\n    __internal__extraTypes;\n    constructor(registry, value) {\n        const extensionTypes = objectSpread({}, registry.getSignedExtensionTypes(), registry.getSignedExtensionExtra());\n        super(registry, objectSpread({}, extensionTypes, knownTypes, { withSignedTransaction: 'bool' }), value);\n        this.__internal__extraTypes = {};\n        const getter = (key) => this.get(key);\n        // add all extras that are not in the base types\n        for (const [key, type] of Object.entries(extensionTypes)) {\n            if (!knownTypes[key]) {\n                this.__internal__extraTypes[key] = type;\n            }\n            objectProperty(this, key, getter);\n        }\n    }\n    get address() {\n        return this.getT('address');\n    }\n    get blockHash() {\n        return this.getT('blockHash');\n    }\n    get blockNumber() {\n        return this.getT('blockNumber');\n    }\n    get era() {\n        return this.getT('era');\n    }\n    get genesisHash() {\n        return this.getT('genesisHash');\n    }\n    get method() {\n        return this.getT('method');\n    }\n    get nonce() {\n        return this.getT('nonce');\n    }\n    get runtimeVersion() {\n        return this.getT('runtimeVersion');\n    }\n    get signedExtensions() {\n        return this.getT('signedExtensions');\n    }\n    get tip() {\n        return this.getT('tip');\n    }\n    get assetId() {\n        return this.getT('assetId');\n    }\n    get version() {\n        return this.getT('version');\n    }\n    get mode() {\n        return this.getT('mode');\n    }\n    get metadataHash() {\n        return this.getT('metadataHash');\n    }\n    get withSignedTransaction() {\n        const val = this.getT('withSignedTransaction');\n        return val.isTrue;\n    }\n    /**\n     * @description Creates an representation of the structure as an ISignerPayload JSON\n     */\n    toPayload() {\n        const result = {};\n        const keys = Object.keys(this.__internal__extraTypes);\n        // add any explicit overrides we may have\n        for (let i = 0, count = keys.length; i < count; i++) {\n            const key = keys[i];\n            const value = this.getT(key);\n            // Don't include Option.isNone\n            if (!(value instanceof Option) || value.isSome) {\n                // NOTE In the spread below we convert (mostly) to Hex to align\n                // with the typings. In the case of \"unknown\" fields, we use the\n                // primitive toJSON conversion (which is serializable). Technically\n                // we can include isNone in here as well (\"null\" is allowed), however\n                // for empty fields we just skip it completely (historical compat)\n                result[key] = value.toJSON();\n            }\n        }\n        return objectSpread(result, {\n            // the known defaults as managed explicitly and has different\n            // formatting in cases, e.g. we mostly expose a hex format here\n            address: this.address.toString(),\n            assetId: this.assetId ? this.assetId.toJSON() : null,\n            blockHash: this.blockHash.toHex(),\n            blockNumber: this.blockNumber.toHex(),\n            era: this.era.toHex(),\n            genesisHash: this.genesisHash.toHex(),\n            metadataHash: this.metadataHash.isSome ? this.metadataHash.toHex() : null,\n            method: this.method.toHex(),\n            mode: this.mode.toNumber(),\n            nonce: this.nonce.toHex(),\n            signedExtensions: this.signedExtensions.map((e) => e.toString()),\n            specVersion: this.runtimeVersion.specVersion.toHex(),\n            tip: this.tip.toHex(),\n            transactionVersion: this.runtimeVersion.transactionVersion.toHex(),\n            version: this.version.toNumber(),\n            withSignedTransaction: this.withSignedTransaction\n        });\n    }\n    /**\n     * @description Creates a representation of the payload in raw Exrinsic form\n     */\n    toRaw() {\n        const payload = this.toPayload();\n        const data = u8aToHex(this.registry\n            .createTypeUnsafe('ExtrinsicPayload', [payload, { version: payload.version }])\n            // NOTE Explicitly pass the bare flag so the method is encoded un-prefixed (non-decodable, for signing only)\n            .toU8a({ method: true }));\n        return {\n            address: payload.address,\n            data,\n            type: 'payload'\n        };\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
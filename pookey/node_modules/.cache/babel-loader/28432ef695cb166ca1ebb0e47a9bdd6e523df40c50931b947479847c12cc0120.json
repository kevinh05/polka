{"ast":null,"code":"// src/coin.ts\nvar DEFAULT_DECIMALS = 18;\nvar validateDecimals = decimals => {\n  if (typeof decimals !== \"number\") throw new Error(\"Invalid decimals, must be a number\");\n  if (decimals < 1 || decimals > 18) throw new Error(\"Invalid decimals, must be between 0 and 18\");\n  return true;\n};\nvar coinToWeiInBigInt = (value, decimals = DEFAULT_DECIMALS) => {\n  value = value.toString();\n  if (!/^\\d+(\\.\\d+)?$/.test(value)) {\n    throw new Error(\"Invalid value\");\n  }\n  validateDecimals(decimals);\n  const multiplier = 10n ** BigInt(decimals);\n  let [integerPart, fractionalPart = \"\"] = value.split(\".\");\n  fractionalPart = fractionalPart.padEnd(decimals, \"0\").slice(0, decimals);\n  const weiValue = BigInt(integerPart) * multiplier + BigInt(fractionalPart);\n  return weiValue;\n};\nvar coinToWei = (value, decimals = DEFAULT_DECIMALS) => {\n  return coinToWeiInBigInt(value, decimals).toString();\n};\nvar weiToCoin = (weiValue, decimals = DEFAULT_DECIMALS) => {\n  validateDecimals(decimals);\n  const weiBigInt = BigInt(weiValue);\n  const divisor = 10n ** BigInt(decimals);\n  const ethAmountBigInt = weiBigInt / divisor;\n  const remainder = weiBigInt % divisor;\n  const remainderStr = remainder.toString().padStart(decimals, \"0\");\n  const formattedRemainder = remainderStr.replace(/0+$/, \"\");\n  const formattedEthAmount = `${ethAmountBigInt}${formattedRemainder.length > 0 ? \".\" + formattedRemainder : \"\"}`;\n  return formattedEthAmount;\n};\nvar dangerouslyWeiToCoinInFloat = (weiValue, decimals = DEFAULT_DECIMALS) => parseFloat(weiToCoin(weiValue, decimals));\nvar formatNice = (value, formattingThreshold = 1e5) => {\n  const numStr = typeof value === \"string\" ? value : value.toString();\n  const roughNum = parseFloat(numStr);\n  if (isNaN(roughNum)) throw new Error(`Coin.format: Invalid number: ${numStr}`);\n  if (formattingThreshold === -1) {\n    return numStr;\n  }\n  const [integerPart, fractionalPart = \"\"] = numStr.split(\".\");\n  const integerNum = parseInt(integerPart);\n  if (integerNum < formattingThreshold) {\n    if (!fractionalPart) return numStr;\n    const roughRemainder = parseFloat(`0.${fractionalPart}`);\n    let digits = 0;\n    if (roughRemainder < 0.1) digits = 6;else if (integerNum < 1) digits = 4;else if (integerNum < 10) digits = 3;else if (integerNum < 1e4) digits = 2;else if (integerNum < 1e5) digits = 1;\n    let fractionalPadded = fractionalPart.substring(0, digits);\n    if (fractionalPadded.length < 2 && digits >= 2) fractionalPadded = fractionalPadded.padEnd(2, \"0\");\n    if (fractionalPadded.replace(/0/g, \"\") === \"\") return integerPart;\n    if (!fractionalPadded) return integerPart;\n    return `${integerPart}.${fractionalPadded}`;\n  }\n  const suffixes = [\"\", \"K\", \"M\", \"B\", \"T\"];\n  const i = integerNum === 0 ? 0 : Math.min(Math.floor(Math.log(integerNum) / 6.907755278982137), 4);\n  const [integerPartOfNice, fractionalPartOfNice = \"\"] = (integerNum / Math.pow(1e3, i)).toString().split(\".\");\n  const formatted = integerPartOfNice + (fractionalPartOfNice.length > 0 ? \".\" + fractionalPartOfNice.slice(0, 3) : \"\");\n  return `${formatted}${suffixes[i]}`;\n};\nvar formatFixed = (value, precision = 3) => {\n  const numStr = value.toString();\n  if (precision === -1) return numStr;\n  const [integerPart, fractionalPart = \"\"] = numStr.split(\".\");\n  if (!fractionalPart) return numStr;\n  return `${integerPart}.${fractionalPart.substring(0, precision).padEnd(precision, \"0\")}`;\n};\nvar weiFormatNice = (weiValue, decimals = DEFAULT_DECIMALS, formattingThreshold = 1e5) => {\n  return formatNice(weiToCoin(weiValue, decimals), formattingThreshold);\n};\nvar weiFormatFixed = (weiValue, decimals = DEFAULT_DECIMALS, precision = 3) => {\n  return formatFixed(weiToCoin(weiValue, decimals), precision);\n};\nvar weiToGwei = (gwei, decimals = DEFAULT_DECIMALS) => {\n  const weiBigInt = BigInt(gwei);\n  if (weiBigInt < 0n) throw new Error(\"Invalid gwei value\");\n  const divisor = 10n ** (BigInt(decimals) / 2n);\n  const [integerPart, fractionalPart = \"\"] = [(weiBigInt / divisor).toString(), (weiBigInt % divisor).toString().padStart(decimals / 2, \"0\").replace(/0+$/, \"\")];\n  if (!fractionalPart) return integerPart;\n  return `${integerPart}.${fractionalPart}`;\n};\nvar gweiToWei = (gwei, decimals = DEFAULT_DECIMALS) => {\n  const multiplier = 10n ** (BigInt(decimals) / 2n);\n  const [integerPart, fractionalPart = \"\"] = gwei.toString().split(\".\");\n  if (BigInt(integerPart) < 0n) throw new Error(\"Invalid gwei value - must be positive\");\n  const gweiIntegerPartInWei = BigInt(integerPart) * multiplier;\n  if (!fractionalPart) return gweiIntegerPartInWei.toString();\n  const fractionalPartStr = fractionalPart.padEnd(decimals / 2, \"0\").slice(0, decimals / 2);\n  const weiValue = gweiIntegerPartInWei + BigInt(fractionalPartStr);\n  return weiValue.toString();\n};\nvar coinToGwei = (value, decimals = DEFAULT_DECIMALS) => {\n  return weiToGwei(coinToWei(value, decimals), decimals);\n};\nvar gweiToCoin = (value, decimals = DEFAULT_DECIMALS) => {\n  return weiToCoin(gweiToWei(value, decimals), decimals);\n};\nvar cleanUpCoinsValue = value => {\n  return value.toString().trim().replace(/\\.?0+$/, \"\");\n};\nvar Coin = (currency, decimals = DEFAULT_DECIMALS, precision = 3, formattingThreshold = 1e5) => {\n  if (typeof currency !== \"string\") throw new Error(\"Invalid currency, must be a string\");\n  validateDecimals(decimals);\n  const paddedCurrency = currency.trim() === \"\" ? \"\" : ` ${currency.trim()}`;\n  return {\n    coinToWeiInBigInt: value => coinToWeiInBigInt(value, decimals),\n    coinToWei: value => coinToWei(value, decimals),\n    weiToCoin: value => weiToCoin(value, decimals),\n    dangerouslyWeiToCoinInFloat: value => dangerouslyWeiToCoinInFloat(value, decimals),\n    formatNice: value => formatNice(value, formattingThreshold) + paddedCurrency,\n    formatMetric: value => formatNice(value, formattingThreshold),\n    formatFixed: (value, _precision = precision) => formatFixed(value, _precision) + paddedCurrency,\n    formatFixedClean: (value, _precision = precision) => formatFixed(value, _precision),\n    weiFormatNice: value => weiFormatNice(value, decimals, formattingThreshold) + paddedCurrency,\n    weiFormatMetric: value => weiFormatNice(value, decimals, formattingThreshold),\n    weiFormatFixed: (value, _precision = precision) => weiFormatFixed(value, decimals, _precision) + paddedCurrency,\n    weiFormatFixedClean: (value, _precision = precision) => weiFormatFixed(value, decimals, _precision),\n    gwei: {\n      gweiToWei: value => gweiToWei(value, decimals),\n      weiToGwei: value => weiToGwei(value, decimals),\n      gweiToCoin: value => gweiToCoin(value, decimals),\n      coinToGwei: value => coinToGwei(value, decimals)\n    },\n    inAllFormats: (value, _precision = precision) => {\n      const wei = coinToWei(value, decimals);\n      const coins = cleanUpCoinsValue(value);\n      const metric = formatNice(value, formattingThreshold);\n      return {\n        value: coins,\n        metric,\n        nice: metric + paddedCurrency,\n        fixed: formatFixed(value, _precision) + paddedCurrency,\n        exact: coins + paddedCurrency,\n        currency,\n        wei\n      };\n    },\n    weiInAllFormats: (wei, _precision = precision) => {\n      const coins = weiToCoin(wei, decimals);\n      const metric = weiFormatNice(wei, decimals, formattingThreshold);\n      return {\n        value: coins,\n        metric,\n        nice: metric + paddedCurrency,\n        fixed: weiFormatFixed(wei, decimals, _precision) + paddedCurrency,\n        exact: coins + paddedCurrency,\n        currency,\n        wei: wei.toString()\n      };\n    }\n  };\n};\nexport { Coin, DEFAULT_DECIMALS, cleanUpCoinsValue, coinToGwei, coinToWei, coinToWeiInBigInt, dangerouslyWeiToCoinInFloat, formatFixed, formatNice, gweiToCoin, gweiToWei, weiFormatFixed, weiFormatNice, weiToCoin, weiToGwei };","map":{"version":3,"names":["DEFAULT_DECIMALS","validateDecimals","decimals","Error","coinToWeiInBigInt","value","toString","test","multiplier","BigInt","integerPart","fractionalPart","split","padEnd","slice","weiValue","coinToWei","weiToCoin","weiBigInt","divisor","ethAmountBigInt","remainder","remainderStr","padStart","formattedRemainder","replace","formattedEthAmount","length","dangerouslyWeiToCoinInFloat","parseFloat","formatNice","formattingThreshold","numStr","roughNum","isNaN","integerNum","parseInt","roughRemainder","digits","fractionalPadded","substring","suffixes","i","Math","min","floor","log","integerPartOfNice","fractionalPartOfNice","pow","formatted","formatFixed","precision","weiFormatNice","weiFormatFixed","weiToGwei","gwei","gweiToWei","gweiIntegerPartInWei","fractionalPartStr","coinToGwei","gweiToCoin","cleanUpCoinsValue","trim","Coin","currency","paddedCurrency","formatMetric","_precision","formatFixedClean","weiFormatMetric","weiFormatFixedClean","inAllFormats","wei","coins","metric","nice","fixed","exact","weiInAllFormats"],"sources":["C:\\Users\\khyy4\\Documents\\Code-Projects\\polkahack\\pookey\\node_modules\\src\\coin.ts"],"sourcesContent":["export const DEFAULT_DECIMALS = 18\n\nconst validateDecimals = (decimals: any): decimals is number => {\n  if (typeof decimals !== 'number') throw new Error('Invalid decimals, must be a number')\n  if (decimals < 1 || decimals > 18) throw new Error('Invalid decimals, must be between 0 and 18')\n  return true\n}\n\nexport const coinToWeiInBigInt = (value: string | number, decimals: number = DEFAULT_DECIMALS): bigint => {\n  value = value.toString()\n\n  //test that value is string of positive number\n  if (!/^\\d+(\\.\\d+)?$/.test(value)) {\n    throw new Error('Invalid value')\n  }\n  validateDecimals(decimals)\n\n  // Define the multiplier as a BigInt\n  const multiplier = 10n ** BigInt(decimals)\n\n  // Convert the integer part and fractional part separately\n  let [integerPart, fractionalPart = ''] = value.split('.')\n\n  // Ensure the fractional part is not longer than decimals digits\n  fractionalPart = fractionalPart.padEnd(decimals, '0').slice(0, decimals)\n\n  // Combine the integer and fractional parts\n  const weiValue = BigInt(integerPart) * multiplier + BigInt(fractionalPart)\n\n  return weiValue\n}\n\nexport const coinToWei = (value: string | number, decimals: number = DEFAULT_DECIMALS): string => {\n  return coinToWeiInBigInt(value, decimals).toString()\n}\n\nexport const weiToCoin = (weiValue: string | bigint, decimals: number = DEFAULT_DECIMALS): string => {\n  validateDecimals(decimals)\n\n  const weiBigInt = BigInt(weiValue)\n  const divisor = 10n ** BigInt(decimals)\n\n  // Divide the Wei amount by the divisor to get the Ether amount\n  const ethAmountBigInt = weiBigInt / divisor\n  const remainder = weiBigInt % divisor\n\n  // Determine how many digits to keep based on the Ether amount\n  // let digits = 0\n  // const ethAmount = Number(ethAmountBigInt) + (remainder > 0 ? Number(remainder) / 10 ** decimals : 0)\n  // if (ethAmount < 0.1) digits = 6\n  // else if (ethAmount < 1) digits = 4\n  // else if (ethAmount < 10) digits = 3\n  // else if (ethAmount < 100) digits = 2\n  // else if (ethAmount < 100000) digits = 1\n  // For amounts >= 100000, digits remain 0 for integer values\n\n  // Format the fractional part based on the determined digits\n  const remainderStr = remainder.toString()\n    .padStart(decimals, '0')\n  // .substring(0, digits)\n\n  // Remove trailing zeros from the remainder\n  const formattedRemainder = remainderStr.replace(/0+$/, '')\n\n  // Combine the integer part and the fractional part\n  const formattedEthAmount = `${ethAmountBigInt}${formattedRemainder.length > 0 ? '.' + formattedRemainder : ''}`\n\n  return formattedEthAmount\n}\n\nexport const dangerouslyWeiToCoinInFloat = (weiValue: string | bigint, decimals: number = DEFAULT_DECIMALS): number =>\n  parseFloat(weiToCoin(weiValue, decimals))\n\nexport const formatNice = (value: string | number, formattingThreshold: number = 100_000): string => {\n  const numStr = typeof value === 'string' ? value : value.toString()\n  const roughNum = parseFloat(numStr)\n  if (isNaN(roughNum)) throw new Error(`Coin.format: Invalid number: ${numStr}`)\n\n  if (formattingThreshold === -1) {\n    return numStr\n  }\n\n  const [integerPart, fractionalPart = ''] = numStr.split('.')\n  const integerNum = parseInt(integerPart)\n\n  if (integerNum < formattingThreshold) {\n    if (!fractionalPart) return numStr\n\n    const roughRemainder = parseFloat(`0.${fractionalPart}`)\n    let digits = 0\n    if (roughRemainder < 0.1) digits = 6\n    else if (integerNum < 1) digits = 4\n    else if (integerNum < 10) digits = 3\n    else if (integerNum < 10000) digits = 2\n    else if (integerNum < 100000) digits = 1\n    // For amounts >= 100000, digits remain 0 for integer values\n\n    let fractionalPadded = fractionalPart\n      .substring(0, digits)\n    if (fractionalPadded.length < 2 && digits >= 2) fractionalPadded = fractionalPadded.padEnd(2, '0')\n\n    // if fractional part contains only zeroes, remove it\n    if (fractionalPadded.replace(/0/g, '') === '') return integerPart\n    if (!fractionalPadded) return integerPart\n    return `${integerPart}.${fractionalPadded}`\n  }\n\n  const suffixes = [\"\", \"K\", \"M\", \"B\", \"T\"]\n  const i = integerNum === 0\n    ? 0\n    // 6.907... is Math.log(1000), 4 is max index of suffixes\n    : Math.min(Math.floor(Math.log(integerNum) / 6.907755278982137), 4)\n\n  const [integerPartOfNice, fractionalPartOfNice = ''] = (integerNum / Math.pow(1000, i)).toString().split('.')\n  const formatted = integerPartOfNice +\n    (fractionalPartOfNice.length > 0 ? '.' + fractionalPartOfNice.slice(0, 3) : '')\n\n  return `${formatted}${suffixes[i]}`\n}\n\nexport const formatFixed = (value: string | number, precision: number = 3): string => {\n  const numStr = value.toString()\n  if (precision === -1) return numStr\n\n  const [integerPart, fractionalPart = ''] = numStr.split('.')\n  if (!fractionalPart) return numStr\n\n  return `${integerPart}.${fractionalPart.substring(0, precision).padEnd(precision, '0')}`\n}\n\nexport const weiFormatNice = (weiValue: string | bigint, decimals: number = DEFAULT_DECIMALS, formattingThreshold = 100_000): string => {\n  return formatNice(weiToCoin(weiValue, decimals), formattingThreshold)\n}\n\nexport const weiFormatFixed = (weiValue: string | bigint, decimals: number = DEFAULT_DECIMALS, precision: number = 3): string => {\n  return formatFixed(weiToCoin(weiValue, decimals), precision)\n}\n\nexport const weiToGwei = (gwei: string | bigint, decimals: number = DEFAULT_DECIMALS): string => {\n  const weiBigInt = BigInt(gwei)\n  if (weiBigInt < 0n) throw new Error('Invalid gwei value')\n  const divisor = 10n ** (BigInt(decimals) / 2n)\n  const [integerPart, fractionalPart = ''] = [\n    (weiBigInt / divisor).toString(),\n    (weiBigInt % divisor).toString().padStart(decimals / 2, '0').replace(/0+$/, '')\n  ]\n  if (!fractionalPart) return integerPart\n  return `${integerPart}.${fractionalPart}`\n}\n\nexport const gweiToWei = (gwei: string | number | bigint, decimals: number = DEFAULT_DECIMALS): string => {\n  const multiplier = 10n ** (BigInt(decimals) / 2n)\n\n  const [integerPart, fractionalPart = ''] = gwei.toString().split('.')\n  if (BigInt(integerPart) < 0n) throw new Error('Invalid gwei value - must be positive')\n  const gweiIntegerPartInWei = BigInt(integerPart) * multiplier\n  if (!fractionalPart) return gweiIntegerPartInWei.toString()\n\n  const fractionalPartStr = fractionalPart.padEnd(decimals / 2, '0').slice(0, decimals / 2)\n\n  const weiValue = gweiIntegerPartInWei + BigInt(fractionalPartStr)\n  return weiValue.toString()\n}\n\nexport const coinToGwei = (value: string | number, decimals: number = DEFAULT_DECIMALS): string => {\n  return weiToGwei(coinToWei(value, decimals), decimals)\n}\n\nexport const gweiToCoin = (value: string | number, decimals: number = DEFAULT_DECIMALS): string => {\n  return weiToCoin(gweiToWei(value, decimals), decimals)\n}\n\nexport const cleanUpCoinsValue = (value: string | number): string => {\n  return value.toString().trim().replace(/\\.?0+$/, '')\n}\n\nexport const Coin = (\n  currency: string,\n  decimals: number = DEFAULT_DECIMALS,\n  precision: number = 3,\n  formattingThreshold: number = 100_000\n) => {\n  if (typeof currency as any !== 'string') throw new Error('Invalid currency, must be a string')\n  validateDecimals(decimals)\n  const paddedCurrency = currency.trim() === '' ? '' : ` ${currency.trim()}`\n\n  return {\n    coinToWeiInBigInt: (value: string): bigint => coinToWeiInBigInt(value, decimals),\n    coinToWei: (value: string): string => coinToWei(value, decimals),\n    weiToCoin: (value: string | bigint): string => weiToCoin(value, decimals),\n\n    dangerouslyWeiToCoinInFloat: (value: string | bigint): number => dangerouslyWeiToCoinInFloat(value, decimals),\n\n    formatNice: (value: string): string => formatNice(value, formattingThreshold) + paddedCurrency,\n    formatMetric: (value: string): string => formatNice(value, formattingThreshold),\n    formatFixed: (value: string | number, _precision = precision): string => formatFixed(value, _precision) + paddedCurrency,\n    formatFixedClean: (value: string | number, _precision = precision): string => formatFixed(value, _precision),\n    weiFormatNice: (value: string | bigint): string => weiFormatNice(value, decimals, formattingThreshold) + paddedCurrency,\n    weiFormatMetric: (value: string | bigint): string => weiFormatNice(value, decimals, formattingThreshold),\n    weiFormatFixed: (value: string | bigint, _precision = precision): string => weiFormatFixed(value, decimals, _precision) + paddedCurrency,\n    weiFormatFixedClean: (value: string | bigint, _precision = precision): string => weiFormatFixed(value, decimals, _precision),\n\n    gwei: {\n      gweiToWei: (value: string | number | bigint): string => gweiToWei(value, decimals),\n      weiToGwei: (value: string | bigint): string => weiToGwei(value, decimals),\n      gweiToCoin: (value: string | number): string => gweiToCoin(value, decimals),\n      coinToGwei: (value: string | number): string => coinToGwei(value, decimals),\n    },\n\n    inAllFormats: (value: string | number, _precision = precision): ICoinFormats => {\n      const wei = coinToWei(value, decimals)\n      const coins = cleanUpCoinsValue(value)\n      const metric = formatNice(value, formattingThreshold)\n      return {\n        value: coins,\n        metric,\n        nice: metric + paddedCurrency,\n        fixed: formatFixed(value, _precision) + paddedCurrency,\n        exact: coins + paddedCurrency,\n        currency,\n        wei,\n      }\n    },\n\n    weiInAllFormats: (wei: string | bigint, _precision = precision): ICoinFormats => {\n      const coins = weiToCoin(wei, decimals)\n      const metric = weiFormatNice(wei, decimals, formattingThreshold)\n      return {\n        value: coins,\n        metric,\n        nice: metric + paddedCurrency,\n        fixed: weiFormatFixed(wei, decimals, _precision) + paddedCurrency,\n        exact: coins + paddedCurrency,\n        currency,\n        wei: wei.toString(),\n      }\n    }\n  }\n}\n\nexport type ICoinFormats = {\n  value: string\n  metric: string\n  nice: string\n  fixed: string\n  exact: string\n  currency: string\n  wei: string\n}\n\nexport type ICoin = ReturnType<typeof Coin>\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}